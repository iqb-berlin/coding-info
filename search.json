[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Kodieren",
    "section": "",
    "text": "Achtung: Webseite in Entwicklung\n\n\n\nDiese Webseite ist im Aufbau. Die Inhalte sind unvollständig und werden ständig revidiert.\n\n\n\nWillkommen\nIn Studien zur Feststellung von Leistungsständen im Bildungswesen liegt der Arbeitsschritt “Kodieren” zwischen der Datenerhebung - also der Durchführung eines Assessments - und der Datenanalyse. Rohantworten führen zu komplexen Datenstrukturen mit einem großen Wertespektrum, die so kaum auswertbar sind. Kodierung heißt hier, diese Werte einfachen Kategorien (“Codes”) zuzuordnen, die die Antwort im Sinne der Studienzielstellung symbolisieren. Anschließend lassen sich Häufigkeiten für diese Kategorien ermitteln, Zusammenhänge modellieren, und letztlich können empirisch begründete Empfehlungen gegeben werden.\nMit der schrittweisen Nutzung von Computern für Leistungserhebungen eröffnen sich neue Möglichkeiten, die Kodierung zu automatisieren und zu standardisieren. Hierzu entwickelt das IQB Datenstrukturen und Prozesse, die auf diesen Webseiten beschrieben sind.\n\n\nLizenz\nAlle Texte sind unter der Lizenz CC0 veröffentlicht. Die Leitlinien zur Sicherung guter wissenschaftlicher Praxis (s. z. B. DFG-pdf) gebieten gleichwohl, dass die Quellen von Informationen genannt werden sollten.\n\n\nHaftungsausschluss\nAuf diesen Webseiten sind Links auf externe Webseiten in besonderer Weise gekennzeichnet (s. oben die Links zum IQB und zur KMK). Wir prüfen diese Quellen regelmäßig, können aber für diese Seiten und die dort hinterlegten Zusatzmaterialien keine Haftung für Richtigkeit, Vollständigkeit und Aktualität übernehmen. Dafür sind ausschließlich deren Betreiber verantwortlich.\n\n\nTechnische Realisierung\nDieser Webauftritt basiert auf Texten in einer einfachen Syntax Markdown, die anschließend in Html und CSS umgesetzt werden. Hierzu wird Quarto verwendet. Sämtliche Dateien für den Inhalt und die Steuerung sind in einem öffentlich zugänglichen Codeverwaltungssystem gespeichert.\n\n\nKontakt\nTechnische und inhaltliche Fragen zu den Inhalten können Sie an die IT des IQB richten.\nWenn Sie Probleme melden möchten, können Sie auch die Funktion “Problem melden” nutzen, die rechts auf jeder Seite zu finden ist. Sie werden dann zu GitHub weitergeleitet. Es ist ein Account bei GitHub erforderlich.",
    "crumbs": [
      "Start"
    ]
  },
  {
    "objectID": "data-structures/index.html",
    "href": "data-structures/index.html",
    "title": "Datenstrukturen",
    "section": "",
    "text": "Sicht der Datenanalyse\nWenn Datenanalysen durchgeführt werden, benötigen sie im Kern eine zweidimensionale Matrix der Antwortdaten Testperson x Item. Die Testperson wird durch eine ID gekennzeichnet, das Item hat ebenfalls eine ID, und im Kreuzungspunkt findet sich ein Wert, der die Antwort der Testperson repräsentiert. Dann kann man Unterschiede der Personen und der Items analysieren.\nBei der Analyse spielen außerdem zusätzliche Daten eine Rolle, die entweder die Person oder die Items näher beschreiben. So ist z. B. wichtig, in welchem sozioökonomischen Umfeld sich die Schule der Testperson befindet, an welcher Stelle des Testheftes das Item auftauchte oder wie schwer dieses Item ist. Die folgende Grafik veranschaulicht grob eine solche Datenstruktur.\n\n\n\n\n\nclassDiagram\n    direction LR\n    class StudentGroup{\n        String: ID\n        String: Testgruppe\n        List~any~: Metadaten\n    }\n    class Student{\n        String: ID\n        String: Testgruppe\n        List~any~: Metadaten\n    }\n    class Booklet{\n        String: ID\n        String: Label\n        List~any~: Metadaten\n    }\n    class Unit{\n        String: ID\n        String: Label\n        List~any~: Metadaten\n    }\n    class Item{\n        String: ID\n        List~any~: Metadaten\n        int: Value\n    }\n    StudentGroup \"1..*\" &lt;--&gt; \"1..*\" Student\n    Student \"1\" --&gt; \"1..*\" Booklet\n    Booklet \"1\" --&gt; \"1..*\" Unit\n    Unit \"1\" --&gt; \"1..*\" Item\n\n\n\n\n\n\nFür diese Dokumentation spielt dies allerdings keine Rolle. Alle Texte beziehen sich auf die Frage, wo der Wert für das Item herkommt.\n\n\nSicht des Testsystems\nDie Quelle für die Antworten sind vor allem die Interaktionselemente der Aufgabe (Eingabefelder, Ankreuzkästchen, Ablegelisten usw.). Außerdem können Ereignisse (zeitbezogene Zustandsänderungen) Informationen liefern, die in Variablen gespeichert werden (Logvariablen).\n\n\n\n\n\nflowchart TD\n    subgraph Unit\n        subgraph Testdurchführung\n            A(Basisvariablen)\n            style A fill:white\n            B(Logvariablen)\n            style B fill:white\n        end\n        style Testdurchführung fill:#b3b3cc\n        E[Kodierung\\nAbleitung]\n        style E fill:#ff9\n        C(Kodierschema)\n        style C fill:white\n        J(Itemliste)\n        style J fill:white\n    end\n    style Unit fill:#e0e0eb\n    H(Person)\n    style H fill:white\n    D[Primärdatensatz]\n    H--&gt;D\n    E --&gt; D\n    A --&gt; E\n    B --&gt; E\n    C --&gt; E\n    G[Analysedatensatz\\nPerson x Item]\n    D --&gt; G\n    F(Missingschema) --&gt; G\n    style F fill:white\n    K(Unitposition\\nim Testheft) --&gt; G\n    style K fill:white\n    J --&gt; G\n    L(Metadaten\\naus versch. Quellen) --&gt; G\n    style L fill:white\n\n\n\n\n\n\nDie Antworten werden in einer einheitlichen Datenstruktur “Variable” gespeichert. Neben dem Antwortwert ist hier eine Information zum Status (State) zu finden, also ob z. B. das Interaktionselement gesehen wurde, ob eine Bearbeitung stattgefunden hat usw.\nEin Kodierschema enthält alle Informationen für die manuelle oder automatische Kodierung. Die States der Variablen im Kodierprozess wird über eine State-Änderung angezeigt, und nach Abschluss der Kodierung sind die Werte “Code” und “Score” für die Variable gesetzt.\n\n\nItemwert\nZunächst besteht der Itemwert aus dem Score-Wert einer Variablen. Für jedes Item ist hierzu in einer Itemliste eine Variable benannt. Dies kann eine Basisvariable oder eine abgeleitete Variable sein. Der Score-Wert ergibt sich nach der Kodierung, also nach der vollständigen Anwendung des Kodierschemas. Üblicherweise handelt es sich bei dem Scorewert um eine ganze Zahl, i. d. R. 0 oder 1.\nSollten allerdings für die Itemvariable keine gültigen Antwortwerte vorliegen, wird eine negative Zahl für den Itemwert gesetzt. Diese Zahl symbolisiert nach einer allgemeinen Konvention verschiedene Missing-Zustände, die nicht nur aus den Antworten einer Unit ermittelt werden können, sondern zusätzliche Informationen erfordern.\nIn der Tradition der Kompetenzdiagnostik werden zwar zunächst Analysen gerechnet, später jedoch die Missing-Werte rekodiert: Zu 0 = falsch oder zu einem allgemeinen Missing-Wert, der vom verwendeten Analysesystem abhängt (sog. sysmis).",
    "crumbs": [
      "Datenstrukturen"
    ]
  },
  {
    "objectID": "data-structures/missings.html",
    "href": "data-structures/missings.html",
    "title": "Missings",
    "section": "",
    "text": "Mit dem Begriff “Missings” werden Zustände in den Daten kodiert, die von einer normalen auswertbaren Antwort abweichen. Statt eines Wertes, der für die Antwort bzw. für den Code einer Antwort steht, wird in den Datensatz ein Wert eingetragen, der eine fehlerhafte bzw. von der erwarteten Beantwortung abweichende Situation beschreibt. Üblicherweise sind gültige, zulässige Antworten mit positiven Zahlen ausgedrückt, ein Missing jedoch mit einem negativen Wert.",
    "crumbs": [
      "Datenstrukturen",
      "Missings"
    ]
  },
  {
    "objectID": "data-structures/missings.html#missing-by-omission-wenn-leer",
    "href": "data-structures/missings.html#missing-by-omission-wenn-leer",
    "title": "Missings",
    "section": "Missing by Omission wenn leer?",
    "text": "Missing by Omission wenn leer?\nWenn eine Eingabe bearbeitet wurde und dann wieder herausgelöscht, könnte man überlegen, statt einer ungültigen Antwort eine beabsichtigte Auslassung (Omission) anzunehmen. Die Testperson wollte wohl den Ausgangszustand wiederherstellen. Hier gibt es einige Probleme:\n\nBei Interaktionenselementen kann man oft einen Wert als Vorbelegung festlegen. Ein Herauslöschen würde nicht den Anfangszustand wiederherstellen.\nDer Aspect-Player hat ein Eingabeelement, das mit einem Satz ohne Satzzeichen vorbelegt ist. Die Testperson kann nur eingeschränkt Zeichen einfügen oder löschen. Der Wert der Eingabe ist stets mindestens die Vorbelegung. Die Option ‘leer’ gibt es nicht.\nBei einigen Interaktionselementen ist die Testperson vielleicht überzeugt, den Ausgangszustand wiederhergestellt zu haben, es gibt aber unsichtbare Reste der Bearbeitung (z. B. Textmarkierung, GeoGebra: Verschieben und Zurückschieben von Punkten). Das wird unfairerweise dann unsystematisch unterschiedlich bewertet.\n\n\n\n\n\n\n\nUmsetzung\n\n\n\nEin bearbeiteter, aber leerer Wert wird als invalid bewertet. Dieses Standardverhalten kann durch eine Option im Kodierschema geändert werden, und es gibt auch eine Regel, die auf einen leeren Wert prüft. Dann ist es auch möglich, einen Code für einen leeren Wert zu vergeben.",
    "crumbs": [
      "Datenstrukturen",
      "Missings"
    ]
  },
  {
    "objectID": "data-structures/missings.html#state-displayed-überspringen",
    "href": "data-structures/missings.html#state-displayed-überspringen",
    "title": "Missings",
    "section": "State DISPLAYED überspringen?",
    "text": "State DISPLAYED überspringen?\nDas IQB-Testsystem registriert, wenn ein Interaktionselement in den Sichtbereich kommt: State DISPLAYED. Wenn eine Interaktion erfolgte, wird der State VALUE_CHANGED gesetzt (zum State einer Antwort siehe hier). Es gibt nun Interaktionselemente, deren Ausgangswert mit hoher Wahrscheinlichkeit der gewünschte Endwert sein soll und das ist dann auch gelegentlich die richtige Antwort. Im Kodierprozess werden standardmäßig nur Antworten mit State VALUE_CHANGED ausgewertet.\n\n\n\n\n\n\nUmsetzung\n\n\n\nIm Kodierschema gibt es eine Option, mit der man für eine Variable festlegen kann, dass der Wert auch bei DISPLAYED ausgewertet wird, also dann wie VALUE_CHANGED behandelt wird.",
    "crumbs": [
      "Datenstrukturen",
      "Missings"
    ]
  },
  {
    "objectID": "data-structures/missings.html#wo-ist-das-item",
    "href": "data-structures/missings.html#wo-ist-das-item",
    "title": "Missings",
    "section": "Wo ist das Item?",
    "text": "Wo ist das Item?\nWenn es als 17. Teilaufgabe ein Item mit der Instruktion “markiere im Text” gibt, weicht der Ort der Beantwortung (also die Interaktion “Markieren” im Stimulus) räumlich stark vom Ort des Items ab, wie er überlicherweise verstanden wird. Die Frage, ob das Item gesehen wurde, wird aktuell falsch beantwortet: Wenn der Stimulustext gesehen wurde.\n\n\n\n\n\n\nMögliche Umsetzung\n\n\n\nMan könnte für Elemente der Unit, die keine Interaktionselemente sind, eine Art Dummy-Variable einrichten. Deren Wert ist unwichtig, aber sie liefert einen State. Dann könnte ein Textelement (Instruktion des Items) mit in die Kodierung einfließen.",
    "crumbs": [
      "Datenstrukturen",
      "Missings"
    ]
  },
  {
    "objectID": "data-structures/response.html",
    "href": "data-structures/response.html",
    "title": "Datenstruktur “Antwort”",
    "section": "",
    "text": "Die Spezifikation in englischer Sprache finden Sie hier.",
    "crumbs": [
      "Datenstrukturen",
      "Antwort/Variable"
    ]
  },
  {
    "objectID": "data-structures/response.html#neu-als-informationseinheit-angelegt",
    "href": "data-structures/response.html#neu-als-informationseinheit-angelegt",
    "title": "Datenstruktur “Antwort”",
    "section": "Neu als Informationseinheit angelegt",
    "text": "Neu als Informationseinheit angelegt\nWenn eine Antwort als Datenstruktur neu angelegt wird, erhält sie zunächst den State UNSET. Darüber wird signalisiert, dass der Wert noch nicht interpretierbar ist.\n\n\n\nWert\nBeschreibung\n\n\n\n\nUNSET\nNeue Variable im technischen Prozess",
    "crumbs": [
      "Datenstrukturen",
      "Antwort/Variable"
    ]
  },
  {
    "objectID": "data-structures/response.html#im-testsystem",
    "href": "data-structures/response.html#im-testsystem",
    "title": "Datenstruktur “Antwort”",
    "section": "Im Testsystem",
    "text": "Im Testsystem\nWährend der Durchführung eines Tests bzw. einer Befragung werden Variablenwerte als Antwortdaten gesetzt.\n\n\n\n\n\n\n\nWert\nBeschreibung\n\n\n\n\nNOT_REACHED\nTestperson ist noch nicht zu der Stelle gelangt, wo eine Interaktion möglich wäre.\n\n\nDISPLAYED\nDas Interaktionselement wurde der Testperson angezeigt.\n\n\nVALUE_CHANGED\nTestperson hat den Wert geändert.\n\n\n\nAndere Werte sind im Testsystem nur möglich, wenn eine Antwortverarbeitung angestoßen wurde (wie z. B. beim adaptiven Testen).\nFür die Verarbeitung des Antwortwertes ist es erforderlich, dass der State VALUE_CHANGED gesetzt ist. Erst dann wird der Antwortwert als absichtliche Interaktion bewertet und eine Kodierung oder Ableitung kann erfolgen.\nIm Kodierschema kann allerdings auch festgelegt werden, dass bei bestimmten Interaktionselementen bereits der State DISPLAYED eine Verarbeitung erlaubt. Dies ist dann der Fall, wenn das Element einen Ausgangswert hat, der eventuell absichtlich nicht von der Testperson verändert wird. Beispiel hier ist ein Ankreuzkästchen, dessen Ausgangswert false/unchecked vielleicht so bleiben soll und dann sogar die richtige Antwort darstellt. Bei einer Instruktion “Kreuze alle Säugetiere an!” muss die Auswahl “Amsel” unbearbeitet bleiben und dann aber trotzdem in die Auswertung einfließen.",
    "crumbs": [
      "Datenstrukturen",
      "Antwort/Variable"
    ]
  },
  {
    "objectID": "data-structures/response.html#bei-ableitung",
    "href": "data-structures/response.html#bei-ableitung",
    "title": "Datenstruktur “Antwort”",
    "section": "Bei Ableitung",
    "text": "Bei Ableitung\nDas Kodierschema des IQB erlaubt das Definieren neuer Variablen auf der Grundlage anderer Variablen der Unit. Diese sog. Ableitung kann nur erfolgen, wenn die Quellvariablen einen hinreichenden State haben:\n\nVariablen, deren Wert (Value) in die abgeleitete Variable eingeht, müssen vor der Kodierung den State VALUE_CHANGED haben. Es ist auch der State DISPLAYED möglich, wenn dies bei der Quellvariablen markiert wurde.\nVariablen, deren Code oder Score in die abgeleitete Variable eingeht, müssen den State CODING_COMPLETE haben.\n\n\n\n\n\n\n\n\nWert\nBeschreibung\n\n\n\n\nDERIVE_ERROR\nWährend der Ableitung ist ein Fehler aufgetreten.\n\n\nVALUE_CHANGED\nFür die abgeleitete Variable wurde erfolgreich ein Wert ermittelt.\n\n\n\nWenn die o. g. erforderlichen Stati bei den Quellvariablen nicht gefunden wurden, ist der Value der abgeleiteten Variable nullund es wird der State auf den kleinsten State gesetzt, der bei den Quellvariablen gefunden wurde. Es gilt folgende Rangfolge:\nUNSET  NOT_REACHED  DISPLAYED  DERIVE_ERROR  NO_CODING  INVALID  CODING_INCOMPLETE  CODING_ERROR",
    "crumbs": [
      "Datenstrukturen",
      "Antwort/Variable"
    ]
  },
  {
    "objectID": "data-structures/response.html#bei-kodierung",
    "href": "data-structures/response.html#bei-kodierung",
    "title": "Datenstruktur “Antwort”",
    "section": "Bei Kodierung",
    "text": "Bei Kodierung\n\n\n\n\n\n\n\nWert\nBeschreibung\n\n\n\n\nNO_CODING\nEs gibt im Kodierschema keine Vorschriften oder Anweisungen für die Kodierung.\n\n\nINVALID\nDer Antwortwert ist ungültig. Dies ist auch der Standard-State, wenn eine Antwort gegeben wurde, aber leer ist (vorheriger State VALUE_CHANGED).\n\n\nCODING_INCOMPLETE\nDie Regeln der automatischen Kodierung wurden angewendet, haben aber keinen zutreffenden Code ermitteln können.\n\n\nCODING_ERROR\nBeim Anwenden der Regeln zur automatischen Kodierung ist ein Fehler aufgetreten. Das kann auch an einer fehlerhaften Regel liegen.\n\n\nCODING_COMPLETE\nEin Code wurde zugewiesen. Damit ist automatisch auch das Setzen von Score verbunden.\n\n\n\nDie Kodierung folgt zunächst den Festlegungen der automatischen Kodierung (regelbasiert). Sollte kein zutreffender Code gefunden werden, dann wird der Code CODING_INCOMPLETE gesetzt. Dann – und auch bei einem Kodierfehler CODING_ERROR – folgt die Sichtung der Antwort und eine manuelle Kodierung. Hier können wiederum die Stati CODING_COMPLETE oder INVALID gesetzt werden.",
    "crumbs": [
      "Datenstrukturen",
      "Antwort/Variable"
    ]
  },
  {
    "objectID": "data-structures/coding-scheme.html",
    "href": "data-structures/coding-scheme.html",
    "title": "Kodierschema",
    "section": "",
    "text": "Auf dieser Seite sind in komprimierter Form alle Parameter und möglichen Werte eines Kodierschemas beschrieben. Andere Quellen:",
    "crumbs": [
      "Datenstrukturen",
      "Kodierschema"
    ]
  },
  {
    "objectID": "data-structures/coding-scheme.html#id",
    "href": "data-structures/coding-scheme.html#id",
    "title": "Kodierschema",
    "section": "id",
    "text": "id\nDie möglichen Werte hier sind recht weit gefasst. Es sind zwar nur Buchstaben, Ziffern und ’_’ erlaubt, aber es gibt keine Mindestlänge und die ID kann nur aus Ziffern bestehen.\nAls Quelle der Variablen-ID fungieren zunächst die Basisvariablen – also die Variablen, die als Interaktionselemente in der Unit-Definition angelegt sind. Darüber hinaus können abgeleitete Variablen Teil des Kodierschemas sein, deren ID lediglich eindeutig innerhalb der Liste sein muss.",
    "crumbs": [
      "Datenstrukturen",
      "Kodierschema"
    ]
  },
  {
    "objectID": "data-structures/coding-scheme.html#label",
    "href": "data-structures/coding-scheme.html#label",
    "title": "Kodierschema",
    "section": "label",
    "text": "label\nDiese Angabe ist meist unnötig, wird also leer gelassen. Erforderlich könnte sie werden, wenn der Ort der Variablen nicht eindeutig ist, weil es viele kleine Interaktionselemente gibt. Dann kann man hier ‘Spalte 2 Zeile 5’ eintragen, um bei der manuellen Kodierung oder der Datenauswertung die Fehlerrate zu senken.",
    "crumbs": [
      "Datenstrukturen",
      "Kodierschema"
    ]
  },
  {
    "objectID": "data-structures/coding-scheme.html#sourcetype",
    "href": "data-structures/coding-scheme.html#sourcetype",
    "title": "Kodierschema",
    "section": "sourceType",
    "text": "sourceType\nHier wird festgelegt, woher der Wert der Variablen kommt:\n\nBASE: Es handelt sich um eine Basisvariable. Der Wert stammt also aus der Interaktion der Testperson mit dem Testsystem.\nCOPY_VALUE: Der Wert dieser abgeleiteten Variable ist eine identische Kopie eines Wertes einer anderen Variable. Dies ist erforderlich, wenn ein Eingabewert nicht nur eine isolierte Information liefern soll, sondern mehrere Aspekte des Wertes getrennt analysiert und also kodiert werden sollen. Beispiel: Es soll getrennt bewertet werden, ob die Großschreibung eingehalten und das Dehnungs-H richtig gesetzt wurde (Orthografie-Items).\nCONCAT_CODE: Der Wert dieser abgeleiteten Variable setzt sich aus den Codes anderer Variablen zusammen. Die Integer-Werte der Codes werden mit dem Trennzeichen ’_’ aneinander gekettet. Der neue Wert der Variablen ist also ein String.\nSUM_CODE: Der Wert dieser abgeleiteten Variable ist der Summenwert der Codes anderer Variablen. Durch geschicktes Festlegen der Codes lassen sich gut zusammenfassende Werte bilden. Der neue Wert der Variablen ist also ein Integer.\nSUM_SCORE: Der Wert dieser abgeleiteten Variable ist der Summenwert der Scores anderer Variablen. Damit wird meistens die Bewertung mehrerer Antworten für ein Item zusammengefasst. Ein Item gilt also dann als richtig beantwortet, wenn einige Teilleistungen richtig sind. Der neue Wert der Variablen ist ein Integer.\nUNIQUE_VALUES: Der Wert dieser abgeleiteten Variablen ist ein Boolscher Wert true/false mit dem festgestellt werden kann, ob die Werte der Quellvariablen eindeutig sind. Sowie einer der Werte mehrfach vorkommt, wird false gesetzt. Bei dieser Ableitung reicht es, wenn eine der Quellvariablen den Status VALUE_CHANGED hat.\nSOLVER: Diese Ableitung setzt numerische Werte bei den Quellvariablen voraus und verknüpft diese mit einem mathematischen Ausdruck, der als separater Parameter übergeben werden muss (s. u.). Es entsteht wieder ein numerischer Wert.",
    "crumbs": [
      "Datenstrukturen",
      "Kodierschema"
    ]
  },
  {
    "objectID": "data-structures/coding-scheme.html#sourceparameters",
    "href": "data-structures/coding-scheme.html#sourceparameters",
    "title": "Kodierschema",
    "section": "sourceParameters",
    "text": "sourceParameters\nÜber diese Parameter wird die Ableitung gesteuert bzw. der Wert noch einmal verändert vor der Kodierung.\n\nsolverExpression: Nur für Ableitung SOLVER; hier ist der Ausdruck zu übergeben, mit dem die Werte bei der Ableitung verknüpft werden. Es müssen für alle Variablenwerte Platzhalter existieren in der Form ${var04}. Diese Stelle wird ersetzt durch den Wert der Variablen var04, bevor der Ausdruck an die Bibliothek math.js zur Auswertung übergeben wird. Alle referenzierten Variablen müssen in deriveSources (s. u.) gelistet sein. Der Funktionsumfang des Ausdruckes richtet sich nach math.evaluate(). Wenn der Wert für den Ausdruck leer ist oder wenn die referenzierten Variablen nicht gefunden werden, wird der Status DERIVE_ERROR gesetzt.\nprocessing: Diese Schalter regeln spezielle Umformungen, die die anschließende Kodierung vorbereitet. Es handelt sich technisch um eine Liste von Schlüsselworten, deren Vorhandensein in der Liste den Schalter auf ‘ON’ setzt:\n\nTAKE_DISPLAYED_AS_VALUE_CHANGED: Nur für Basisvariablen; legt fest, dass der Wert der Variablen auch ausgewertet wird, wenn die Variable den Status DISPLAYED hat. Ansonsten werden nur Variablen berücksichtigt, deren Status auf VALUE_CHANGED gesetzt ist.\nTAKE_EMPTY_AS_VALID: Nur für Basisvariablen; legt fest, dass ein leerer Wert als gültig angesehen wird und in die Kodierung gegeben wird. Das Standardverhalten bei leerer Antwort ist das Setzen des Status’ INVALID\nREMOVE_ALL_SPACES, REMOVE_DISPENSABLE_SPACES, TO_NUMBER, TO_LOWER_CASE: Nur für Ableitung UNIQUE_VALUES; die Werte werden vor der Gleichheitsprüfung transformiert. So kann man verhindern, dass ein führendes Leerzeichen oder eine vorgesetzte ‘0’ eine Verschiedenheit vortäuscht. Achtung: Wenn TO_NUMBER nicht erfolgreich war, also z. B. ein String nicht in eine Zahl überführt werden konnte, wird ‘0’ gesetzt. Passiert dies zweimal, liefert die Ableitung false.\nSORT: Nur für Ableitung CONCAT_CODE; wenn es egal ist, welche Variable welchen Code liefert, erleichtert eine Sortierung die Kodierung.",
    "crumbs": [
      "Datenstrukturen",
      "Kodierschema"
    ]
  },
  {
    "objectID": "data-structures/coding-scheme.html#derivesources",
    "href": "data-structures/coding-scheme.html#derivesources",
    "title": "Kodierschema",
    "section": "deriveSources",
    "text": "deriveSources\nDies ist eine Liste von IDs der Variablen, die als Quelle dienen. Die Reihenfolge ist verbindlich, was allerdings nur beim Ableitungstyp CONCAT_CODE eine Rolle spielt, sofern nicht als Parameter SORT gesetzt wurde.\nWenn eine Variable angegeben wurde, die nicht im Kodierschema enthalten ist, wird der Status DERIVE_ERROR gesetzt.",
    "crumbs": [
      "Datenstrukturen",
      "Kodierschema"
    ]
  },
  {
    "objectID": "data-structures/coding-scheme.html#processing",
    "href": "data-structures/coding-scheme.html#processing",
    "title": "Kodierschema",
    "section": "processing",
    "text": "processing\nÜber diese Schalter kann man den generellen Umgang mit Werten und Vergleichswerten verändern. Es handelt sich technisch um eine Liste von Schlüsselworten, deren Vorhandensein in der Liste den Schalter auf ‘ON’ setzt:\n\nIGNORE_CASE: Groß- und Kleinschreibung spielt keine Rolle. Sowohl der Antwort-Wert als auch der Vergleichswert einer Regel werden vor dem Vergleich in Großbuchstaben umgewandelt (s. JavaScript toUpperCase()).\nIGNORE_ALL_SPACES, IGNORE_DISPENSABLE_SPACES: Leerzeichen spielen keine Rolle. Sowohl im Antwortwert als auch im Vergleichswert einer Regel werden vor dem Vergleich alle Leerzeichen (ALL) oder Leerzeichen am Beginn und am Ende sowie doppelte Leerzeichen (DISPENSABLE) entfernt. Als Leerzeichen dient hier die Zeichenklasse \\\\sgemäß JavaScript reguläre Ausdrücke.\nSORT_ARRAY: Sofern der Antwortwert aus einem Array besteht, wird dieses vor der Kodierung sortiert. Leere Antwortwerte im Array werden ans Ende geschoben. Dies kann die Kodierregeln erheblich vereinfachen.\nREPLAY_REQUIRED: Mit dieser Information wird darüber informiert, dass eine Kodierung nicht abstrakt mit dem Antwortwert erfolgen kann, sondern über eine Ansicht der Unit mit den Antwortwerten. Diese Information kann hilfreich bei der Planung der Kodierungen sein.\nATTACHMENT: Der Antwortwert ist ein Verweis auf eine externe Datei. Diese muss dann für die Kodierung herangezogen werden. Beispielsweise könnte ein Foto einer Zeichnung oder eine Audio-Aufnahme auf diese Art als Antwort kodiert werden.\n\nDie Schalter IGNORE_CASE, IGNORE_ALL_SPACES und IGNORE_DISPENSABLE_SPACES gelten nur für die Regel MATCH. Bei MATCH_REGEX und den numerischen Regeln werden sie ignoriert.",
    "crumbs": [
      "Datenstrukturen",
      "Kodierschema"
    ]
  },
  {
    "objectID": "data-structures/coding-scheme.html#fragmenting",
    "href": "data-structures/coding-scheme.html#fragmenting",
    "title": "Kodierschema",
    "section": "fragmenting",
    "text": "fragmenting\nÜber einen regulären Ausdruck kann ein Antwortwert zerlegt werden. Interaktionselemente können komplexe Daten in einfache Strings mit definierten Trennzeichen konvertieren, und durch die Fragmentierung werden die Teildaten getrennt auswertbar. Eine Regel (s. u.) bezieht sich dann nicht auf den gesamten Antwortwert, sondern nur auf ein Fragment. Es werden keine geschachtelten Gruppen unterstützt.\n\nBeispiel 1: Ein Textelement in einem Player speichert eine Textmarkierung durch die Testperson über einen Wert 23_92_yellow, was der Startposition, der Endposition und der Farbe der Markierung entspricht. Der Wert kann über den regulären Ausdruck ^(\\d+)_(\\d+)_(\\w+)$ fragmentiert werden, so dass man die einzelnen Informationen getrennt bewerten kann.\n\n\nBeispiel 2: Eine Eingabe 2 kg kann über (\\d+)\\s*(\\w+) zerlegt werden.",
    "crumbs": [
      "Datenstrukturen",
      "Kodierschema"
    ]
  },
  {
    "objectID": "data-structures/coding-scheme.html#manualinstruction",
    "href": "data-structures/coding-scheme.html#manualinstruction",
    "title": "Kodierschema",
    "section": "manualInstruction",
    "text": "manualInstruction\nSollten für alle codespezifischen Instruktionen (s. u.) allgemeine übergreifende Festlegungen gewünscht sein, dann können diese hier hinterlegt werden. Beispielsweise kann man hier die Kodieranweisung eingeben, es möge die Rechtschreibung bei allen Codes beachtet werden.\nDieser Text kann Html-Formatierungen enthalten. Dazu gehören auch Bilder, die dann über die Binärkodierung base64 eingebettet sind.\n\n\n\n\n\n\nSicherheitshinweis\n\n\n\nBei der Anzeige dieser Texte ist stets darauf zu achten, dass Code entfernt wird (über sog. HTML Sanitizer). Ein Verzicht darauf würde eine Sicherheitslücke bedeuten.\n\n\nIm Prozess der Erarbeitung der Kodiervorschriften kann es nützlich sein, diesen Text als allgemeinen Notizzettel zu verwenden. Erste Überlegungen oder Hinweise einer Aufgabenentwicklerin können hier gespeichert werden (z. B. ‘dritte Option ist richtig’), und später könnte ein erfahrener Autor die genauen Code-Regeln definieren.",
    "crumbs": [
      "Datenstrukturen",
      "Kodierschema"
    ]
  },
  {
    "objectID": "data-structures/coding-scheme.html#codemodel",
    "href": "data-structures/coding-scheme.html#codemodel",
    "title": "Kodierschema",
    "section": "codeModel",
    "text": "codeModel\nDiese Festlegung hat keine Bedeutung für die Kodierung. Sie ist dafür gedacht, die sehr komplexen Parameter eines Kodierschemas übersichtlicher zu gestalten.\n\nNONE: Kein Modell (Voreinstellung)\nCHOICE: Geschlossenes Kodierschema für eine endliche Liste numerischer Werte (automatische Kodierung)\nVALUE_LIST: Geschlossenes Kodierschema für eine endliche Liste alphanumerischer Werte (automatische Kodierung)\nNUMBER: Kodierschema für die Kodierung numerischer Werte. Es werden nur Regeln angezeigt, die für einen numerischen Vergleich gedacht sind.\nMANUAL: Manuelle Kodierung; sämtliche Optionen für automatische Kodierung werden ausgeblendet.",
    "crumbs": [
      "Datenstrukturen",
      "Kodierschema"
    ]
  },
  {
    "objectID": "data-structures/coding-scheme.html#page",
    "href": "data-structures/coding-scheme.html#page",
    "title": "Kodierschema",
    "section": "page",
    "text": "page\nSollte der Player die Unit auf verschiedene Seiten verteilen, dient dies normalerweise dem Verteilen eines umfangreichen Inhaltes auf u. U. nicht sichtbare Bereich. Es ist dann ein Blättern nötig, um alle Interaktionselemente zu erreichen. Bei der Kodierung ist es sehr hilfreich, wenn man beim Replay – also der Anzeige des letzten Standes der Beantwortung – gleich zur richtigen Seite der Variablen springt und nicht erst blättern muss. Ein leerer Eintrag ''bedeutet, dass es entweder nur eine Seite gibt oder dass die Variable nicht verlässlich einer Seite zugeordnet werden kann (z. B. bei abgeleiteten Variablen).",
    "crumbs": [
      "Datenstrukturen",
      "Kodierschema"
    ]
  },
  {
    "objectID": "data-structures/coding-scheme.html#id-1",
    "href": "data-structures/coding-scheme.html#id-1",
    "title": "Kodierschema",
    "section": "id",
    "text": "id\nDies ist der Wert, der als Ergebnis der Kodierung dem Parameter code der Antwortdaten zugewiesen wird. Es handelt sich um einen numerischen ganzahligen Wert.\nDiese id kann auch den Wert null annehmen. Dann bleiben die Parameter code und score gleich 0, aber der Parameter status wird auf den Wert INVALID gesetzt. Es sind dann also Bedingungen beschrieben, die die Antwort als ungültig klassifizieren sollen. Beispiel: Eine alternative Auswahl hat 4 Optionen. Dann kann man für diese vier Optionen reguläre Codes 1-4 vorsehen, und eine abweichende Antwort (‘Alle anderen Antworten’) ist ungültig. Damit ist das Kodierschema ‘geschlossen’, d. h. es gibt immer ein eindeutiges Ergebnis.\n\n\n\n\n\n\nGefahr von Verschleiern eines Problems\n\n\n\nWenn ein eigentlich unmöglicher Wert mit INVALID markiert wird, könnte ein ernstes Problem in der Datenverarbeitung oder im Player dahinter stecken. Derartige Fälle sollten stets genauer untersucht werden.",
    "crumbs": [
      "Datenstrukturen",
      "Kodierschema"
    ]
  },
  {
    "objectID": "data-structures/coding-scheme.html#label-1",
    "href": "data-structures/coding-scheme.html#label-1",
    "title": "Kodierschema",
    "section": "label",
    "text": "label\nDiese Kurzfassung der folgenden Regeln und Instruktionen soll für den Code eine Orientierung geben in Listen. Üblich ist hier z. B. RICHTIG u. ä.",
    "crumbs": [
      "Datenstrukturen",
      "Kodierschema"
    ]
  },
  {
    "objectID": "data-structures/coding-scheme.html#score",
    "href": "data-structures/coding-scheme.html#score",
    "title": "Kodierschema",
    "section": "score",
    "text": "score\nWenn der Code zutrifft, wird auch stets der Parameter score der Antwortdaten gesetzt. Es handelt sich um einen numerischen ganzahligen Wert.",
    "crumbs": [
      "Datenstrukturen",
      "Kodierschema"
    ]
  },
  {
    "objectID": "data-structures/coding-scheme.html#manualinstruction-1",
    "href": "data-structures/coding-scheme.html#manualinstruction-1",
    "title": "Kodierschema",
    "section": "manualInstruction",
    "text": "manualInstruction\nHier sind Instruktionen an eine reale Person gespeichert, die nach Sichtung der Antwort manuell einen Code vergeben soll. Dies kann auch ergänzend zu Regeln sein: Für Standardfälle werden Regeln definiert, die eine automatische Kodierung – soweit möglich – vornehmen, und erst wenn kein Code gefunden wurde, muss eine Person manuell evaluieren. Hierbei ist darauf zu achten, dass keine Regel ‘Alle anderen Antworten’ hinterlegt ist, da sonst dieser Code automatisch vergeben wird und nicht CODING_INCOMPLETE.\nDieser Text kann Html-Formatierungen enthalten. Dazu gehören auch Bilder, die dann über die Binärkodierung base64 eingebettet sind.\n\n\n\n\n\n\nSicherheitshinweis\n\n\n\nBei der Anzeige dieser Texte ist stets darauf zu achten, dass Code entfernt wird (über sog. HTML Sanitizer). Ein Verzicht darauf würde eine Sicherheitslücke bedeuten.",
    "crumbs": [
      "Datenstrukturen",
      "Kodierschema"
    ]
  },
  {
    "objectID": "data-structures/coding-scheme.html#rulesetoperatorand",
    "href": "data-structures/coding-scheme.html#rulesetoperatorand",
    "title": "Kodierschema",
    "section": "ruleSetOperatorAnd",
    "text": "ruleSetOperatorAnd\nWenn dieser boolesche Wert true ist, dann werden die Ergebnisse der Regelsätze mit UND verknüpft. Alle Regelsätze müssen true liefern, damit der Code als zutreffend bewertet wird. Bei false reicht es, dass ein Regelsatz true ergibt (ODER-Verknüpfung).",
    "crumbs": [
      "Datenstrukturen",
      "Kodierschema"
    ]
  },
  {
    "objectID": "data-structures/coding-scheme.html#rulesets",
    "href": "data-structures/coding-scheme.html#rulesets",
    "title": "Kodierschema",
    "section": "ruleSets",
    "text": "ruleSets\nRegelsätze fassen mehrere Regeln zusammen in einer Gruppe. Ein Regelsatz hat folgende Parameter:\n\nvalueArrayPos: Sollte der Antwortwert eine Liste von Werten sein,\n\nstellt dieser Parameter einen Bezug zu einer bestimmten Position im Array her (Datentyp Integer 0..n-1), oder\nsoll mindestens ein Wert im Array gefunden werden, der die Bedingungen erfüllt (Datentyp String ANY), oder\nsollen vor der Auswertung alle Array-Werte bzw. alle Fragmente als numerische Werte interpretiert und summiert werden (Datentyp String SUM)\n\nruleOperatorAnd: Wenn dieser boolesche Wert true ist, dann werden die Ergebnisse der Regeln mit UND verknüpft. Alle Regeln müssen true liefern, damit der Code als zutreffend bewertet wird. Bei false reicht es, dass eine Regel true ergibt (ODER-Verknüpfung).",
    "crumbs": [
      "Datenstrukturen",
      "Kodierschema"
    ]
  },
  {
    "objectID": "data-structures/coding-scheme.html#rules",
    "href": "data-structures/coding-scheme.html#rules",
    "title": "Kodierschema",
    "section": "rules",
    "text": "rules\nRegeln sind Vorschriften, die jeweils einen Wert analysieren nach einem vorgegebenen Muster. Die Anwendung einer Regel liefert stets ein ‘Match’, also ob ein Wert einer bestimmten Erwartung entspricht.\n\nfragment: Das Kodierschema für eine Variable kann im Parameter fragmenting einen regulären Ausdruck enthalten, der einen Wert in mehrere Teile zerlegt (s. o.). Eine Regel kann sich über den Parameter fragment (Datentyp Integer) auf ein bestimmtes Fragment beziehen. Es wird eine ganze positive Zahl als Array-Position erwartet oder ‘-1’ dafür, dass irgendein Fragment die Bedingung erfüllen muss.\nmethod:\n\nMATCH: Es wird eine Übereinstimmung geprüft (String-Vergleich). Hierfür ist EIN Parameter nötig (s. u.). Ist der Parameterwert mehrzeilig, wird pro Zeile die Übereinstimmung geprüft.\nMATCH_REGEX: Es wird eine Übereinstimmung geprüft (String-Vergleich über regulären Ausdruck). Hierfür ist EIN Parameter nötig (s. u.). Ist der Parameterwert mehrzeilig, wird pro Zeile die Übereinstimmung geprüft. Es wird die JavaScript-Funktion match() verwendet, wobei ein Ergebnis ungleich null als positiv gewertet wird.\nNUMERIC_MATCH: Es wird eine Übereinstimmung geprüft. Hierfür ist EIN Parameter nötig (s. u.). Ist der Parameterwert mehrzeilig, wird pro Zeile die Übereinstimmung geprüft. Wert und Vergleichswert werden vor der Prüfung in einen numerischen Wert transformiert. Eventuell vorhandene Leerzeichen werden vorher komplett entfernt, und ein Komma wird ggf. durch einen Dezimalpunkt ersetzt.\nNUMERIC_RANGE: Es wird geprüft, ob der Wert im Bereich “min &lt; Wert &lt;= max” liegt. Hierfür sind ZWEI Parameter nötig (s. u.). Die Aufbereitung der Werte siehe NUMERIC_MATCH.\nNUMERIC_LESS_THAN: Es wird geprüft, ob der Wert kleiner als der Parameterwert ist. Hierfür ist EIN Parameter nötig (s. u.). Die Aufbereitung der Werte siehe NUMERIC_MATCH.\nNUMERIC_MORE_THAN: Es wird geprüft, ob der Wert größer als der Parameterwert ist. Hierfür ist EIN Parameter nötig (s. u.). Die Aufbereitung der Werte siehe NUMERIC_MATCH.\nNUMERIC_MAX: Es wird geprüft, ob der Wert höchstens der Parameterwert ist. Hierfür ist EIN Parameter nötig (s. u.). Die Aufbereitung der Werte siehe NUMERIC_MATCH.\nNUMERIC_MIN: Es wird geprüft, ob der Wert mindestens der Parameterwert ist. Hierfür ist EIN Parameter nötig (s. u.). Die Aufbereitung der Werte siehe NUMERIC_MATCH.\nIS_EMPTY: Prüft, ob der Wert leer ist. Wenn es sich um eine Basisvariable handelt, die kein Array ist, muss bei sourceParameter/processing der Schalter TAKE_EMPTY_AS_VALID gesetzt sein, damit die leere Antwort ausgewertet wird. Diese Regel sollte im ersten Code platziert sein, da andere Regeln u. U. einen CODING_ERROR erzeugen, wenn der Antwortwert leer ist.\nELSE: Diese Regel bezieht sich nicht auf einen bestimmten Wert, sondern trifft immer zu. Sie prüft nichts, sondern der Code, der diese Regel enthält, wird als zutreffend evaluiert. Sie sollte also im letzten Code definiert sein, wenn das Kodierschema geschlossen werden soll.\nIS_NULL: Prüft, ob der Wert null ist im Sinne der Datentypdefinition von JavaScript. Diese Regel sollte im ersten Code platziert sein, da andere Regeln u. U. einen CODING_ERROR erzeugen, wenn der Antwortwert null ist.\nIS_TRUE, IS_FALSE: Prüft, ob der Wert wahr bzw. falsch ist.\n\nparameters: Einige Regeln benötigen einen Parameter, eine sogar zwei. Diese Parameter werden hier gespeichert. Der Datentyp ist eine Liste (Array) von Strings.",
    "crumbs": [
      "Datenstrukturen",
      "Kodierschema"
    ]
  }
]