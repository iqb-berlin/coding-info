[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Kodieren",
    "section": "",
    "text": "Achtung: Webseite in Entwicklung\n\n\n\nDiese Webseite ist im Aufbau. Die Inhalte sind unvollständig und werden ständig revidiert.\n\n\n\nWillkommen\nIn Studien zur Feststellung von Leistungsständen im Bildungswesen liegt der Arbeitsschritt “Kodieren” zwischen der Datenerhebung - also der Durchführung eines Assessments - und der Datenanalyse. Rohantworten führen zu komplexen Datenstrukturen mit einem großen Wertespektrum, die so kaum auswertbar sind. Kodierung heißt hier, diese Werte einfachen Kategorien (“Codes”) zuzuordnen, die die Antwort im Sinne der Studienzielstellung symbolisieren. Anschließend lassen sich Häufigkeiten für diese Kategorien ermitteln, Zusammenhänge modellieren, und letztlich können empirisch begründete Empfehlungen gegeben werden.\nMit der schrittweisen Nutzung von Computern für Leistungserhebungen eröffnen sich neue Möglichkeiten, die Kodierung zu automatisieren und zu standardisieren. Hierzu entwickelt das IQB Datenstrukturen und Prozesse, die auf diesen Webseiten beschrieben sind.\n\n\nLizenz\nAlle Texte sind unter der Lizenz CC0 veröffentlicht. Die Leitlinien zur Sicherung guter wissenschaftlicher Praxis (s. z. B. DFG-pdf) gebieten gleichwohl, dass die Quellen von Informationen genannt werden sollten.\n\n\nHaftungsausschluss\nAuf diesen Webseiten sind Links auf externe Webseiten in besonderer Weise gekennzeichnet (s. oben die Links zum IQB und zur KMK). Wir prüfen diese Quellen regelmäßig, können aber für diese Seiten und die dort hinterlegten Zusatzmaterialien keine Haftung für Richtigkeit, Vollständigkeit und Aktualität übernehmen. Dafür sind ausschließlich deren Betreiber verantwortlich.\n\n\nTechnische Realisierung\nDieser Webauftritt basiert auf Texten in einer einfachen Syntax Markdown, die anschließend in Html und CSS umgesetzt werden. Hierzu wird Quarto verwendet. Sämtliche Dateien für den Inhalt und die Steuerung sind in einem öffentlich zugänglichen Codeverwaltungssystem gespeichert.\n\n\nKontakt\nTechnische und inhaltliche Fragen zu den Inhalten können Sie an die IT des IQB richten.\nWenn Sie Probleme melden möchten, können Sie auch die Funktion “Problem melden” nutzen, die rechts auf jeder Seite zu finden ist. Sie werden dann zu GitHub weitergeleitet. Es ist ein Account bei GitHub erforderlich.",
    "crumbs": [
      "Start"
    ]
  },
  {
    "objectID": "data-structures/missings.html",
    "href": "data-structures/missings.html",
    "title": "Missings",
    "section": "",
    "text": "Mit dem Begriff “Missings” werden Zustände in den Daten kodiert, die von einer normalen auswertbaren Antwort abweichen. Statt eines Wertes, der für die Antwort bzw. für den Code einer Antwort steht, wird in den Datensatz ein Wert eingetragen, der eine fehlerhafte bzw. von der erwarteten Beantwortung abweichende Situation beschreibt. Üblicherweise sind gültige, zulässige Antworten mit positiven Zahlen ausgedrückt, ein Missing jedoch mit einem negativen Wert.",
    "crumbs": [
      "Datenstrukturen",
      "Missings"
    ]
  },
  {
    "objectID": "data-structures/missings.html#missing-by-omission-wenn-leer",
    "href": "data-structures/missings.html#missing-by-omission-wenn-leer",
    "title": "Missings",
    "section": "Missing by Omission wenn leer?",
    "text": "Missing by Omission wenn leer?\nWenn eine Eingabe bearbeitet wurde und dann wieder herausgelöscht, könnte man überlegen, statt einer ungültigen Antwort eine beabsichtigte Auslassung (Omission) anzunehmen. Die Testperson wollte wohl den Ausgangszustand wiederherstellen. Hier gibt es einige Probleme:\n\nBei Interaktionenselementen kann man oft einen Wert als Vorbelegung festlegen. Ein Herauslöschen würde nicht den Anfangszustand wiederherstellen.\nDer Aspect-Player hat ein Eingabeelement, das mit einem Satz ohne Satzzeichen vorbelegt ist. Die Testperson kann nur eingeschränkt Zeichen einfügen oder löschen. Der Wert der Eingabe ist stets mindestens die Vorbelegung. Die Option ‘leer’ gibt es nicht.\nBei einigen Interaktionselementen ist die Testperson vielleicht überzeugt, den Ausgangszustand wiederhergestellt zu haben, es gibt aber unsichtbare Reste der Bearbeitung (z. B. Textmarkierung, GeoGebra: Verschieben und Zurückschieben von Punkten). Das wird unfairerweise dann unsystematisch unterschiedlich bewertet.\n\n\n\n\n\n\n\nUmsetzung\n\n\n\nEin bearbeiteter, aber leerer Wert wird als invalid bewertet. Dieses Standardverhalten kann durch eine Option im Kodierschema geändert werden, und es gibt auch eine Regel, die auf einen leeren Wert prüft. Dann ist es auch möglich, einen Code für einen leeren Wert zu vergeben.",
    "crumbs": [
      "Datenstrukturen",
      "Missings"
    ]
  },
  {
    "objectID": "data-structures/missings.html#status-displayed-überspringen",
    "href": "data-structures/missings.html#status-displayed-überspringen",
    "title": "Missings",
    "section": "Status DISPLAYED überspringen?",
    "text": "Status DISPLAYED überspringen?\nDas IQB-Testsystem registriert, wenn ein Interaktionselement in den Sichtbereich kommt: Status DISPLAYED. Wenn eine Interaktion erfolgte, wird der Status VALUE_CHANGED gesetzt (zum Status einer Antwort siehe hier). Es gibt nun Interaktionselemente, deren Ausgangswert mit hoher Wahrscheinlichkeit der gewünschte Endwert sein soll und das ist dann auch gelegentlich die richtige Antwort. Im Kodierprozess werden standardmäßig nur Antworten mit Status VALUE_CHANGED ausgewertet.\n\n\n\n\n\n\nUmsetzung\n\n\n\nIm Kodierschema gibt es eine Option, mit der man für eine Variable festlegen kann, dass der Wert auch bei DISPLAYED ausgewertet wird, also dann wie VALUE_CHANGED behandelt wird.",
    "crumbs": [
      "Datenstrukturen",
      "Missings"
    ]
  },
  {
    "objectID": "data-structures/missings.html#wo-ist-das-item",
    "href": "data-structures/missings.html#wo-ist-das-item",
    "title": "Missings",
    "section": "Wo ist das Item?",
    "text": "Wo ist das Item?\nWenn es als 17. Teilaufgabe ein Item mit der Instruktion “markiere im Text” gibt, weicht der Ort der Beantwortung (also die Interaktion “Markieren” im Stimulus) räumlich stark vom Ort des Items ab, wie er überlicherweise verstanden wird. Die Frage, ob das Item gesehen wurde, wird aktuell falsch beantwortet: Wenn der Stimulustext gesehen wurde.\n\n\n\n\n\n\nMögliche Umsetzung\n\n\n\nMan könnte für Elemente der Unit, die keine Interaktionselemente sind, eine Art Dummy-Variable einrichten. Deren Wert ist unwichtig, aber sie liefert einen Status. Dann könnte ein Textelement (Instruktion des Items) mit in die Kodierung einfließen.",
    "crumbs": [
      "Datenstrukturen",
      "Missings"
    ]
  },
  {
    "objectID": "data-structures/response.html",
    "href": "data-structures/response.html",
    "title": "Datenstruktur “Antwort”",
    "section": "",
    "text": "Die Spezifikation in englischer Sprache finden Sie hier.",
    "crumbs": [
      "Datenstrukturen",
      "Antwort/Variable"
    ]
  },
  {
    "objectID": "data-structures/response.html#neu-als-informationseinheit-angelegt",
    "href": "data-structures/response.html#neu-als-informationseinheit-angelegt",
    "title": "Datenstruktur “Antwort”",
    "section": "Neu als Informationseinheit angelegt",
    "text": "Neu als Informationseinheit angelegt\nWenn eine Antwort als Datenstruktur neu angelegt wird, erhält sie zunächst den Status UNSET. Darüber wird signalisiert, dass der Wert noch nicht interpretierbar ist.\n\n\n\nWert\nBeschreibung\n\n\n\n\nUNSET\nNeue Variable im technischen Prozess",
    "crumbs": [
      "Datenstrukturen",
      "Antwort/Variable"
    ]
  },
  {
    "objectID": "data-structures/response.html#im-testsystem",
    "href": "data-structures/response.html#im-testsystem",
    "title": "Datenstruktur “Antwort”",
    "section": "Im Testsystem",
    "text": "Im Testsystem\nWährend der Durchführung eines Tests bzw. einer Befragung werden Variablenwerte als Antwortdaten gesetzt.\n\n\n\n\n\n\n\nWert\nBeschreibung\n\n\n\n\nNOT_REACHED\nTestperson ist noch nicht zu der Stelle gelangt, wo eine Interaktion möglich wäre.\n\n\nDISPLAYED\nDas Interaktionselement wurde der Testperson angezeigt.\n\n\nVALUE_CHANGED\nTestperson hat den Wert geändert.\n\n\n\nAndere Werte sind im Testsystem nur möglich, wenn eine Antwortverarbeitung angestoßen wurde (wie z. B. beim adaptiven Testen).\nFür die Verarbeitung des Antwortwertes ist es erforderlich, dass der Status VALUE_CHANGED gesetzt ist. Erst dann wird der Antwortwert als absichtliche Interaktion bewertet und eine Kodierung oder Ableitung kann erfolgen.\nIm Kodierschema kann allerdings auch festgelegt werden, dass bei bestimmten Interaktionselementen bereits der Status DISPLAYED eine Verarbeitung erlaubt. Dies ist dann der Fall, wenn das Element einen Ausgangswert hat, der eventuell absichtlich nicht von der Testperson verändert wird. Beispiel hier ist ein Ankreuzkästchen, dessen Ausgangswert false/unchecked vielleicht so bleiben soll und dann sogar die richtige Antwort darstellt. Bei einer Instruktion “Kreuze alle Säugetiere an!” muss die Auswahl “Amsel” unbearbeitet bleiben und dann aber trotzdem in die Auswertung einfließen.",
    "crumbs": [
      "Datenstrukturen",
      "Antwort/Variable"
    ]
  },
  {
    "objectID": "data-structures/response.html#bei-ableitung",
    "href": "data-structures/response.html#bei-ableitung",
    "title": "Datenstruktur “Antwort”",
    "section": "Bei Ableitung",
    "text": "Bei Ableitung\nDas Kodierschema des IQB erlaubt das Definieren neuer Variablen auf der Grundlage anderer Variablen der Unit. Diese sog. Ableitung kann nur erfolgen, wenn die Quellvariablen einen hinreichenden Status haben:\n\nVariablen, deren Wert (Value) in die abgeleitete Variable eingeht, müssen vor der Kodierung den Status VALUE_CHANGED haben. Es ist auch der Status DISPLAYED möglich, wenn dies bei der Quellvariablen markiert wurde.\nVariablen, deren Code oder Score in die abgeleitete Variable eingeht, müssen den Status CODING_COMPLETE haben.\n\n\n\n\n\n\n\n\nWert\nBeschreibung\n\n\n\n\nDERIVE_ERROR\nWährend der Ableitung ist ein Fehler aufgetreten.\n\n\nVALUE_CHANGED\nFür die abgeleitete Variable wurde erfolgreich ein Wert ermittelt.\n\n\n\nWenn die o. g. erforderlichen Stati bei den Quellvariablen nicht gefunden wurden, ist der Value der abgeleiteten Variable nullund es wird der Status auf den kleinsten Status gesetzt, der bei den Quellvariablen gefunden wurde. Es gilt folgende Rangfolge:\nUNSET  NOT_REACHED  DISPLAYED  DERIVE_ERROR  NO_CODING  INVALID  CODING_INCOMPLETE  CODING_ERROR",
    "crumbs": [
      "Datenstrukturen",
      "Antwort/Variable"
    ]
  },
  {
    "objectID": "data-structures/response.html#bei-kodierung",
    "href": "data-structures/response.html#bei-kodierung",
    "title": "Datenstruktur “Antwort”",
    "section": "Bei Kodierung",
    "text": "Bei Kodierung\n\n\n\n\n\n\n\nWert\nBeschreibung\n\n\n\n\nNO_CODING\nEs gibt im Kodierschema keine Vorschriften oder Anweisungen für die Kodierung.\n\n\nINVALID\nDer Antwortwert ist ungültig. Dies ist auch der Standard-Status, wenn eine Antwort gegeben wurde, aber leer ist (vorheriger Status VALUE_CHANGED).\n\n\nCODING_INCOMPLETE\nDie Regeln der automatischen Kodierung wurden angewendet, haben aber keinen zutreffenden Code ermitteln können.\n\n\nCODING_ERROR\nBeim Anwenden der Regeln zur automatischen Kodierung ist ein Fehler aufgetreten. Das kann auch an einer fehlerhaften Regel liegen.\n\n\nCODING_COMPLETE\nEin Code wurde zugewiesen. Damit ist automatisch auch das Setzen von Score verbunden.\n\n\n\nDie Kodierung folgt zunächst den Festlegungen der automatischen Kodierung (regelbasiert). Sollte kein zutreffender Code gefunden werden, dann wird der Code CODING_INCOMPLETE gesetzt. Dann – und auch bei einem Kodierfehler CODING_ERROR – folgt die Sichtung der Antwort und eine manuelle Kodierung. Hier können wiederum die Stati CODING_COMPLETE oder INVALID gesetzt werden.",
    "crumbs": [
      "Datenstrukturen",
      "Antwort/Variable"
    ]
  },
  {
    "objectID": "data-structures/itc-ToolBox-Output/tc-merge.html",
    "href": "data-structures/itc-ToolBox-Output/tc-merge.html",
    "title": "Output itc-ToolBox: TC-Merge",
    "section": "",
    "text": "person\nEine TC-Merge-Datei ist stets eine Liste von Personen.\n\ngroup: ID der Gruppe laut Testtaker-Xml\nlogin: Name des Logins laut Testtaker-Xml\ncode: Code innerhalb des Booklet-Tags in der Testtaker-Xml (ggf. leer)\nbooklets: Liste der Booklets - s. u.\n\n[\n    {\n        \"group\": \"cxz7hpwr\",\n        \"login\": \"cxz7hpwr\",\n        \"code\": \"1dpe\",\n        \"booklets\": [ ]\n    },\n    {\n        \"group\": \"cxz7hpwr\",\n        \"login\": \"cxz7hpwr\",\n        \"code\": \"1fud\",\n        \"booklets\": [ ]\n    }\n]\nDie itc-ToolBox ist darauf ausgerichtet, bei hohen Datenmengen pro Testtaker-Gruppe eine Datei anzulegen. Möchte man die gesamte Datenmenge einlesen, müssen diese einzelnen Listen zusammengeführt werden. Da die JSON-Datei formatiert ist, kann man entsprechend die erste bzw. letzte Zeile einer Datei löschen bzw. ersetzen.\n\n\nbooklet\n\nid: ID des Booklets laut Booklet-Xml\nlogs: Liste von Log-Einträgen (Ereignissen), bezogen auf das Booklet\n\nts: Zeitstempel des Ereignisses (numerisch)\nkey: Schlüsselwort, das das Ereignis kennzeichnet (Typ), z. B. CURRENT_UNIT_ID, LOADCOMPLETE oder FOCUS\nparameter: Weitere Informationen als String zum Ereignis, abhängig vom Typ\n\nunits: Liste der Units - s. u.\nsessions: Liste von gestarteten Bearbeitungen des Booklets\n\nbrowser: Name und Version des verwendeten Browsers, z. B. Chrome 123.0.0.0\nos: Name und Version des Betriebssystem, z. B. Windows 10\nscreen: Maße des Bildschirmes in Pixel, z. B. 1280 x 720,\nts: Zeitstempel der Ermittlung der Parameter (numerisch), z. B. 1715593740477\nloadCompleteMS: Dauer des Ladeprozesses der Testinhalte (Player, Units, Booklet) in ms (numerisch), z. B. 798\n\n\nEine neue Session wird angenommen, wenn in den Logs das Ereignis LOADCOMPLETE gefunden wurde. Dies zeigt einen abgeschlossenen Ladeprozess der Testinhalte an. Der Startzeitpunkt einer Session kann angenommen werden, wenn man vom Zeitstempel ts den Wert in loadCompleteMS subtrahiert.\n{\n    \"id\": \"ABIEVALBOOKLET_BE_FRANZOESISCH_GN_LONG\",\n    \"logs\": [\n        {\n            \"ts\": 1719466289261,\n            \"key\": \"CONNECTION\",\n            \"parameter\": \"POLLING\"\n        },\n        {\n            \"ts\": 1719466289253,\n            \"key\": \"CONTROLLER\",\n            \"parameter\": \"RUNNING\"\n        },\n        {\n            \"ts\": 1719466289361,\n            \"key\": \"CURRENT_UNIT_ID\",\n            \"parameter\": \"Unit1\"\n        },\n        {\n            \"ts\": 1719466289672,\n            \"key\": \"CONNECTION\",\n            \"parameter\": \"WEBSOCKET\"\n        }\n    ],\n    \"units\": [ ],\n    \"sessions\": [\n        {\n            \"browser\": \"Chrome 103.0.0.0\",\n            \"os\": \"Mac OS 10.12.6\",\n            \"screen\": \"1440 x 900\",\n            \"ts\": 1719466289928,\n            \"loadCompleteMS\": 1805\n        },\n        {\n            \"browser\": \"Chrome 103.0.0.0\",\n            \"os\": \"Mac OS 10.12.6\",\n            \"screen\": \"1440 x 900\",\n            \"ts\": 1719485971651,\n            \"loadCompleteMS\": 1858\n        }\n    ]\n}         \n\n\nunit\n\nid: ID der Unit laut Booklet-Xml; wird benötigt, wenn man die Definition, das Kodierschema oder andere Daten der Unit benötigt\nalias: Alias der Unit\n\ndieser kann in der Booklet-Xml vergeben werden oder er wird automatisch erzeugt, sollte eine Unit mehrfach in einem Booklet vorkommen\nwird kein Alias vergeben, wird hier automatisch die ID der Unit gesetzt\nalle Bezüge in den Logs und Antwortdaten beziehen sich auf den Alias\n\nlaststate: Liste von key/value-Paaren, um bestimmte für das Zurückblättern wichtige Unit-Zustände zu rekonstruieren\nsubforms: Liste der Antworten - s. u.\nchunks: Liste der Pakete der Antworten; die Verona-Spezifikation erlaubt es, dass Antworten nicht einzeln, sondern gebündelt in dataparts geschickt werden\n\nid: jeder Chunk/datapart muss eine ID haben\ntype: Datentyp der Antworten; bei IQB-Daten stets iqb-standard@1.0 bzw. andere Version\nts: Zeitstempel der Speicherung (numerisch)\nvariables: Liste von IDs von Variablen, die mit dem Paket geschickt wurden; sollten Unterformulare genutzt worden sein, wird als Präfix der Wert von subform gesetzt, gefolgt von einem Trenner, z. B. examineecount_0##choice1\n\nlogs: Liste von Log-Einträgen (Ereignissen), bezogen auf die Unit\n\nts: Zeitstempel des Ereignisses (numerisch)\nkey: Schlüsselwort, das das Ereignis kennzeichnet (Typ), z. B. RESPONSE_PROGRESS oder CURRENT_PAGE_ID\nparameter: Weitere Informationen als String zum Ereignis, abhängig vom Typ\n\n\n{\n    \"id\": \"MP_motivation1\",\n    \"alias\": \"MP_motivation1_start\",\n    \"laststate\": [\n        {\n            \"key\": \"PLAYER\",\n            \"value\": \"RUNNING\"\n        },\n        {\n            \"key\": \"PRESENTATION_PROGRESS\",\n            \"value\": \"complete\"\n        },\n        {\n            \"key\": \"RESPONSE_PROGRESS\",\n            \"value\": \"complete\"\n        }\n    ],\n    \"subforms\": [ ],\n    \"chunks\": [\n        {\n            \"id\": \"elementCodes\",\n            \"type\": \"iqb-standard@1.0\",\n            \"ts\": \"1715593741455\",\n            \"variables\": [\n            \"text_4\",\n            \"image_1\",\n            \"button_2\"\n            ]\n        }\n    ],\n    \"logs\": [\n        {\n            \"ts\": 1715593739823,\n            \"key\": \"PLAYER\",\n            \"parameter\": \"LOADING\"\n        },\n        {\n            \"ts\": 1715593740340,\n            \"key\": \"PLAYER\",\n            \"parameter\": \"RUNNING\"\n        },\n        {\n            \"ts\": 1715593741013,\n            \"key\": \"PRESENTATION_PROGRESS\",\n            \"parameter\": \"complete\"\n        },\n        {\n            \"ts\": 1715593741013,\n            \"key\": \"RESPONSE_PROGRESS\",\n            \"parameter\": \"complete\"\n        }\n    ]\n}\n\n\nsubform, response\nEine Antwort nach IQB-Standardformat enthält ein optionales Attribut subform. Für die Datenverarbeitung ist es günstiger, diese Information - die z. B. in Befragungen genutzt wird - zu extrahieren und alle Variablen eines Unterformulars zu bündeln. Aus diesem Grund ist das Datenobjekt für die Antworten nocheinmal strukturiert:\n\nid: ID des Unterformulars bzw. leer\nresponses: Liste der Antwortdaten\n\nid: Variablen-ID\nstatus: Status der Beantwortung; z. B. DISPLAYED oder VALUE_CHANGED\nvalue: Antwortwert als String\n\n\n{\n        \"id\": \"examineecount_0\",\n        \"responses\": [\n            {\n                \"id\": \"sex\",\n                \"status\": \"VALUE_CHANGED\",\n                \"value\": \"2\"\n            },\n            {\n                \"id\": \"choice1\",\n                \"status\": \"VALUE_CHANGED\",\n                \"value\": \"1\"\n            },\n            {\n                \"id\": \"task11grade\",\n                \"status\": \"VALUE_CHANGED\",\n                \"value\": \"14\"\n            },\n            {\n                \"id\": \"choice2\",\n                \"status\": \"VALUE_CHANGED\",\n                \"value\": \"2\"\n            },\n            {\n                \"id\": \"task22grade\",\n                \"status\": \"VALUE_CHANGED\",\n                \"value\": \"14\"\n            }\n        ]\n},\n{\n    \"id\": \"examineecount_1\",\n    \"responses\": [\n        {\n            \"id\": \"sex\",\n            \"status\": \"VALUE_CHANGED\",\n            \"value\": \"2\"\n        },\n        {\n            \"id\": \"choice1\",\n            \"status\": \"VALUE_CHANGED\",\n            \"value\": \"1\"\n        },\n        {\n            \"id\": \"task11grade\",\n            \"status\": \"VALUE_CHANGED\",\n            \"value\": \"9\"\n        },\n        {\n            \"id\": \"choice2\",\n            \"status\": \"VALUE_CHANGED\",\n            \"value\": \"2\"\n        },\n        {\n            \"id\": \"task22grade\",\n            \"status\": \"VALUE_CHANGED\",\n            \"value\": \"9\"\n        }\n    ]\n}\n\n\n\n\n\n\nDatenformat des Antwortwertes\n\n\n\nIn streng typisierten Computersprachen ist die offene IQB-Datenspezifikation des Antwortwertes problematisch. Daher werden hier die Werte in String transformiert. Der Datenwert null ist hierbei in einen reservierten Wert \"#null#\" übersetzt. Auch Array-Werte müssen entsprechend vor der Kodierung transformiert werden.\n\n\n\n\n\n\n\n\nBehandlung großer Antwortwerte\n\n\n\nWenn ein Wert mit den Zeichen data:application/octet-stream;base64 beginnt, handelt es sich meist um die Speicherung einer binären, nicht automatisch kodierbaren Antwort. Um die Datenmenge zu reduzieren, ermöglicht die itc-ToolBox, den Wert als separate Datei zu speichern:\n\nDer Dateiname wird folgendermaßen gebildet:\n\nDaten der Person Gruppe, Login-Name und Code - hintereinander ohne Trennzeichen\nTrennzeichen _\nnumerischer Hash-Wert der Datei (ganzzahlig positiv oder negativ)\nDateiendung .base64\nBeispiel: b7tr7svhb7tr7svh7rbr_-611842233.base64\n\nDer Antwortwert wird ersetzt durch die Zeichenfolge data:application/octet-stream;base64 Filename: '&lt;Dateiname&gt;'",
    "crumbs": [
      "Datenstrukturen",
      "itc-ToolBox Output",
      "Format TC-Merge"
    ]
  },
  {
    "objectID": "workflow/index.html",
    "href": "workflow/index.html",
    "title": "Arbeitsschritte",
    "section": "",
    "text": "Die Schritte der Datenverarbeitung unterscheiden sich, je nachdem, ob eine genauere Analyse der Itemeigenschaften erfolgen soll (DIF, Distraktorenanalyse usw.) oder die Studie der Ermittlung von Personenkennwerten dient. Nachfolgend wird vom letzteren Fall ausgegangen, da für die Itemanalyse (Erprobung, Pilotierung) jederzeit nach Bedarf abgezweigt werden kann.",
    "crumbs": [
      "Arbeitsschritte"
    ]
  },
  {
    "objectID": "workflow/index.html#gegebene-antworten",
    "href": "workflow/index.html#gegebene-antworten",
    "title": "Arbeitsschritte",
    "section": "Gegebene Antworten",
    "text": "Gegebene Antworten\n\n\n\n\n\n\n\n\nStatus\nNeuer Code\nBeschreibung\n\n\n\n\nCODING_COMPLETE\n-\nWird nicht rekodiert, da ein gültiger verwertbarer Code bereits vergeben wurde.\n\n\nNO_CODING\n-\nHier handelt es sich z. B. um freie Eingaben, die nicht kodiert werden sollen (z. B. Sprache zu Hause). Diese müssen aus den Daten extrahiert werden, da sie nicht in die Datenanalyse einfließen.\n\n\nINVALID\n-98\nmir - missing invalid response\n\n\nCODING_ERROR\n-97\nmci - missing coding impossible",
    "crumbs": [
      "Arbeitsschritte"
    ]
  },
  {
    "objectID": "workflow/index.html#mögliche-aber-nicht-gegebene-antworten",
    "href": "workflow/index.html#mögliche-aber-nicht-gegebene-antworten",
    "title": "Arbeitsschritte",
    "section": "Mögliche, aber nicht gegebene Antworten",
    "text": "Mögliche, aber nicht gegebene Antworten\n\nDas Testheft-Design muss abgefragt werden um festzustellen, welche Units (und damit Variablen) in den Antwortdaten zu finden sein müssten und welche nicht. Es muss für die Units, die der Testperson vorgelegt wurden, eine Reihenfolge (Sequenz) bekannt sein.\n\n\nFür die letzte in der Sequenz der vorgelegten Units\n\n\n\nStatus\nNeuer Code\nBeschreibung\n\n\n\n\nUNSET, DISPLAYED\n-99\nmbo - missing by omission\n\n\nNOT_REACHED\n-96\nmnr - missing not reached\n\n\n\n\n\nFür alle vorherigen Units\n\n\n\n\n\n\n\n\nStatus\nNeuer Code\nBeschreibung\n\n\n\n\nUNSET, DISPLAYED, NOT_REACHED\n-99\nmbo - missing by omission\n\n\n\n\n\nFür alle nicht gefundenen Variablen\n\nUnits VOR der letzten: -99 (mbo - missing by omission)\nUnits NACH der letzten: -96 (mnr - missing not reached)",
    "crumbs": [
      "Arbeitsschritte"
    ]
  },
  {
    "objectID": "workflow/index.html#nicht-mögliche-antworten",
    "href": "workflow/index.html#nicht-mögliche-antworten",
    "title": "Arbeitsschritte",
    "section": "Nicht mögliche Antworten",
    "text": "Nicht mögliche Antworten\n\nVariablen werden hinzugefügt, die der Person planmäßig nicht vorgelegt wurden, aber in der Studie vorgesehen sind. Sie erhalten alle den Code -94 (mbd - missing by design).",
    "crumbs": [
      "Arbeitsschritte"
    ]
  },
  {
    "objectID": "data-structures/coding-scheme.html",
    "href": "data-structures/coding-scheme.html",
    "title": "Kodierschema",
    "section": "",
    "text": "Auf dieser Seite sind in komprimierter Form alle Parameter und möglichen Werte eines Kodierschemas beschrieben. Andere Quellen:",
    "crumbs": [
      "Datenstrukturen",
      "Kodierschema"
    ]
  },
  {
    "objectID": "data-structures/coding-scheme.html#id",
    "href": "data-structures/coding-scheme.html#id",
    "title": "Kodierschema",
    "section": "id",
    "text": "id\nDie möglichen Werte hier sind recht weit gefasst. Es sind zwar nur Buchstaben, Ziffern und ’_’ erlaubt, aber es gibt keine Mindestlänge und die ID kann nur aus Ziffern bestehen.\nAls Quelle der Variablen-ID fungieren zunächst die Basisvariablen – also die Variablen, die als Interaktionselemente in der Unit-Definition angelegt sind. Darüber hinaus können abgeleitete Variablen Teil des Kodierschemas sein, deren ID lediglich eindeutig innerhalb der Liste sein muss.",
    "crumbs": [
      "Datenstrukturen",
      "Kodierschema"
    ]
  },
  {
    "objectID": "data-structures/coding-scheme.html#alias",
    "href": "data-structures/coding-scheme.html#alias",
    "title": "Kodierschema",
    "section": "alias",
    "text": "alias\nEin Alias ist eine alternative ID, die durch User vergeben werden kann. Dann kann die ID der Variable nicht mehr geändert werden und bleibt konstant über alle Verarbeitungsschritte und Versionen. Der Alias kann aber nach Bedarf geändert werden. Das IQB hat diese Trennung eingeführt, als sich Umbenennungen von Variablen häuften und jede Umbenennung Inkonsistenzen verursachte (Ableitungen schlugen fehl, Seitenzustände wurden falsch ermittelt).",
    "crumbs": [
      "Datenstrukturen",
      "Kodierschema"
    ]
  },
  {
    "objectID": "data-structures/coding-scheme.html#label",
    "href": "data-structures/coding-scheme.html#label",
    "title": "Kodierschema",
    "section": "label",
    "text": "label\nDiese Angabe ist meist unnötig, wird also leer gelassen. Erforderlich könnte sie werden, wenn der Ort der Variablen nicht eindeutig ist, weil es viele kleine Interaktionselemente gibt. Dann kann man hier ‘Spalte 2 Zeile 5’ eintragen, um bei der manuellen Kodierung oder der Datenauswertung die Fehlerrate zu senken.",
    "crumbs": [
      "Datenstrukturen",
      "Kodierschema"
    ]
  },
  {
    "objectID": "data-structures/coding-scheme.html#sourcetype",
    "href": "data-structures/coding-scheme.html#sourcetype",
    "title": "Kodierschema",
    "section": "sourceType",
    "text": "sourceType\nHier wird festgelegt, woher der Wert der Variablen kommt:\n\nBASE: Es handelt sich um eine Basisvariable. Der Wert stammt also aus der Interaktion der Testperson mit dem Testsystem.\nCOPY_VALUE: Der Wert dieser abgeleiteten Variable ist eine identische Kopie eines Wertes einer anderen Variable. Dies ist erforderlich, wenn ein Eingabewert nicht nur eine isolierte Information liefern soll, sondern mehrere Aspekte des Wertes getrennt analysiert und also kodiert werden sollen. Beispiel: Es soll getrennt bewertet werden, ob die Großschreibung eingehalten und das Dehnungs-H richtig gesetzt wurde (Orthografie-Items).\nCONCAT_CODE: Der Wert dieser abgeleiteten Variable setzt sich aus den Codes anderer Variablen zusammen. Die Integer-Werte der Codes werden mit dem Trennzeichen ’_’ aneinander gekettet. Der neue Wert der Variablen ist also ein String.\nSUM_CODE: Der Wert dieser abgeleiteten Variable ist der Summenwert der Codes anderer Variablen. Durch geschicktes Festlegen der Codes lassen sich gut zusammenfassende Werte bilden. Der neue Wert der Variablen ist also ein Integer.\nSUM_SCORE: Der Wert dieser abgeleiteten Variable ist der Summenwert der Scores anderer Variablen. Damit wird meistens die Bewertung mehrerer Antworten für ein Item zusammengefasst. Ein Item gilt also dann als richtig beantwortet, wenn einige Teilleistungen richtig sind. Der neue Wert der Variablen ist ein Integer.\nUNIQUE_VALUES: Der Wert dieser abgeleiteten Variablen ist ein Boolscher Wert true/false mit dem festgestellt werden kann, ob die Werte der Quellvariablen eindeutig sind. Sowie einer der Werte mehrfach vorkommt, wird false gesetzt. Bei dieser Ableitung reicht es, wenn eine der Quellvariablen den Status VALUE_CHANGED hat.\nSOLVER: Diese Ableitung setzt numerische Werte bei den Quellvariablen voraus und verknüpft diese mit einem mathematischen Ausdruck, der als separater Parameter übergeben werden muss (s. u.). Es entsteht wieder ein numerischer Wert.",
    "crumbs": [
      "Datenstrukturen",
      "Kodierschema"
    ]
  },
  {
    "objectID": "data-structures/coding-scheme.html#sourceparameters",
    "href": "data-structures/coding-scheme.html#sourceparameters",
    "title": "Kodierschema",
    "section": "sourceParameters",
    "text": "sourceParameters\nÜber diese Parameter wird die Ableitung gesteuert bzw. der Wert noch einmal verändert vor der Kodierung.\n\nsolverExpression: Nur für Ableitung SOLVER; hier ist der Ausdruck zu übergeben, mit dem die Werte bei der Ableitung verknüpft werden. Es müssen für alle Variablenwerte Platzhalter existieren in der Form ${var04}. Diese Stelle wird ersetzt durch den Wert der Variablen var04, bevor der Ausdruck an die Bibliothek math.js zur Auswertung übergeben wird. Alle referenzierten Variablen müssen in deriveSources (s. u.) gelistet sein. Der Funktionsumfang des Ausdruckes richtet sich nach math.evaluate(). Wenn der Wert für den Ausdruck leer ist oder wenn die referenzierten Variablen nicht gefunden werden, wird der Status DERIVE_ERROR gesetzt.\nprocessing: Diese Schalter regeln spezielle Umformungen, die die anschließende Kodierung vorbereitet. Es handelt sich technisch um eine Liste von Schlüsselworten, deren Vorhandensein in der Liste den Schalter auf ‘ON’ setzt:\n\nTAKE_DISPLAYED_AS_VALUE_CHANGED: Nur für Basisvariablen; legt fest, dass der Wert der Variablen auch ausgewertet wird, wenn die Variable den Status DISPLAYED hat. Ansonsten werden nur Variablen berücksichtigt, deren Status auf VALUE_CHANGED gesetzt ist.\nTAKE_EMPTY_AS_VALID: Nur für Basisvariablen; legt fest, dass ein leerer Wert als gültig angesehen wird und in die Kodierung gegeben wird. Das Standardverhalten bei leerer Antwort ist das Setzen des Status’ INVALID. “Leer” bedeutet hier ein leerer String oder ein leeres Array.\nREMOVE_ALL_SPACES, REMOVE_DISPENSABLE_SPACES, TO_NUMBER, TO_LOWER_CASE: Nur für Ableitung UNIQUE_VALUES; die Werte werden vor der Gleichheitsprüfung transformiert. So kann man verhindern, dass ein führendes Leerzeichen oder eine vorgesetzte ‘0’ eine Verschiedenheit vortäuscht. Achtung: Wenn TO_NUMBER nicht erfolgreich war, also z. B. ein String nicht in eine Zahl überführt werden konnte, wird ‘0’ gesetzt. Passiert dies zweimal, liefert die Ableitung false.\nSORT: Nur für Ableitung CONCAT_CODE; wenn es egal ist, welche Variable welchen Code liefert, erleichtert eine Sortierung die Kodierung.",
    "crumbs": [
      "Datenstrukturen",
      "Kodierschema"
    ]
  },
  {
    "objectID": "data-structures/coding-scheme.html#derivesources",
    "href": "data-structures/coding-scheme.html#derivesources",
    "title": "Kodierschema",
    "section": "deriveSources",
    "text": "deriveSources\nDies ist eine Liste von IDs der Variablen, die als Quelle dienen. Die Reihenfolge ist verbindlich, was allerdings nur beim Ableitungstyp CONCAT_CODE eine Rolle spielt, sofern nicht als Parameter SORT gesetzt wurde.\nWenn eine Variable angegeben wurde, die nicht im Kodierschema enthalten ist, wird der Status DERIVE_ERROR gesetzt.\n\n\n\n\n\n\nID – nicht Alias!\n\n\n\nAn dieser Stelle ist wichtig zu betonen, dass bei deriveSources stets die ID und nicht der Alias verwendet wird. Der Vorteil ist, dass eine Umbenennung (also eine Änderung des Alias) keine Auswirkung auf die Ableitung hat. Der Nachteil ist, dass beim Blick auf das Kodierschema Irritationen auftreten können, weil man in der UI nur den Alias sieht.",
    "crumbs": [
      "Datenstrukturen",
      "Kodierschema"
    ]
  },
  {
    "objectID": "data-structures/coding-scheme.html#processing",
    "href": "data-structures/coding-scheme.html#processing",
    "title": "Kodierschema",
    "section": "processing",
    "text": "processing\nÜber diese Schalter kann man den generellen Umgang mit Werten und Vergleichswerten verändern. Es handelt sich technisch um eine Liste von Schlüsselworten, deren Vorhandensein in der Liste den Schalter auf ‘ON’ setzt:\n\nIGNORE_CASE: Groß- und Kleinschreibung spielt keine Rolle. Sowohl der Antwort-Wert als auch der Vergleichswert einer Regel werden vor dem Vergleich in Großbuchstaben umgewandelt (s. JavaScript toUpperCase()).\nIGNORE_ALL_SPACES, IGNORE_DISPENSABLE_SPACES: Leerzeichen spielen keine Rolle. Sowohl im Antwortwert als auch im Vergleichswert einer Regel werden vor dem Vergleich alle Leerzeichen (ALL) oder Leerzeichen am Beginn und am Ende sowie doppelte Leerzeichen (DISPENSABLE) entfernt. Als Leerzeichen dient hier die Zeichenklasse \\\\sgemäß JavaScript reguläre Ausdrücke.\nSORT_ARRAY: Sofern der Antwortwert aus einem Array besteht, wird dieses vor der Kodierung sortiert. Leere Antwortwerte im Array werden ans Ende geschoben. Dies kann die Kodierregeln erheblich vereinfachen.\nREPLAY_REQUIRED: Mit dieser Information wird darüber informiert, dass eine Kodierung nicht abstrakt mit dem Antwortwert erfolgen kann, sondern über eine Ansicht der Unit mit den Antwortwerten. Diese Information kann hilfreich bei der Planung der Kodierungen sein.\nATTACHMENT: Der Antwortwert ist ein Verweis auf eine externe Datei. Diese muss dann für die Kodierung herangezogen werden. Beispielsweise könnte ein Foto einer Zeichnung oder eine Audio-Aufnahme auf diese Art als Antwort kodiert werden.\n\nDie Schalter IGNORE_CASE, IGNORE_ALL_SPACES und IGNORE_DISPENSABLE_SPACES gelten nur für die Regel MATCH. Bei MATCH_REGEX wird bei IGNORE_CASE das i-Flag gesetzt, die anderen Schalter werden ignoriert. Bei den numerischen Regeln werden alle Schalter ignoriert.",
    "crumbs": [
      "Datenstrukturen",
      "Kodierschema"
    ]
  },
  {
    "objectID": "data-structures/coding-scheme.html#fragmenting",
    "href": "data-structures/coding-scheme.html#fragmenting",
    "title": "Kodierschema",
    "section": "fragmenting",
    "text": "fragmenting\nÜber einen regulären Ausdruck kann ein Antwortwert zerlegt werden. Interaktionselemente können komplexe Daten in einfache Strings mit definierten Trennzeichen konvertieren, und durch die Fragmentierung werden die Teildaten getrennt auswertbar. Eine Regel (s. u.) bezieht sich dann nicht auf den gesamten Antwortwert, sondern nur auf ein Fragment. Es werden keine geschachtelten Gruppen unterstützt.\n\nBeispiel 1: Ein Textelement in einem Player speichert eine Textmarkierung durch die Testperson über einen Wert 23_92_yellow, was der Startposition, der Endposition und der Farbe der Markierung entspricht. Der Wert kann über den regulären Ausdruck ^(\\d+)_(\\d+)_(\\w+)$ fragmentiert werden, so dass man die einzelnen Informationen getrennt bewerten kann.\n\n\nBeispiel 2: Eine Eingabe 2 kg kann über (\\d+)\\s*(\\w+) zerlegt werden.",
    "crumbs": [
      "Datenstrukturen",
      "Kodierschema"
    ]
  },
  {
    "objectID": "data-structures/coding-scheme.html#manualinstruction",
    "href": "data-structures/coding-scheme.html#manualinstruction",
    "title": "Kodierschema",
    "section": "manualInstruction",
    "text": "manualInstruction\nSollten für alle codespezifischen Instruktionen (s. u.) allgemeine übergreifende Festlegungen gewünscht sein, dann können diese hier hinterlegt werden. Beispielsweise kann man hier die Kodieranweisung eingeben, es möge die Rechtschreibung bei allen Codes beachtet werden.\nDieser Text kann Html-Formatierungen enthalten. Dazu gehören auch Bilder, die dann über die Binärkodierung base64 eingebettet sind.\n\n\n\n\n\n\nSicherheitshinweis\n\n\n\nBei der Anzeige dieser Texte ist stets darauf zu achten, dass Code entfernt wird (über sog. HTML Sanitizer). Ein Verzicht darauf würde eine Sicherheitslücke bedeuten.\n\n\nIm Prozess der Erarbeitung der Kodiervorschriften kann es nützlich sein, diesen Text als allgemeinen Notizzettel zu verwenden. Erste Überlegungen oder Hinweise einer Aufgabenentwicklerin können hier gespeichert werden (z. B. ‘dritte Option ist richtig’), und später könnte ein erfahrener Autor die genauen Code-Regeln definieren.",
    "crumbs": [
      "Datenstrukturen",
      "Kodierschema"
    ]
  },
  {
    "objectID": "data-structures/coding-scheme.html#codemodel",
    "href": "data-structures/coding-scheme.html#codemodel",
    "title": "Kodierschema",
    "section": "codeModel",
    "text": "codeModel\nÜber diesen Parameter wird festgelegt, ob während der Bearbeitung nur die Formularelemente für die Regeln, nur die für die manuelle Kodierung oder alles angezeigt wird. Die möglichen Werte lauten entsprechend RULES_ONLY, MANUAL_ONLY und MANUAL_AND_RULES.",
    "crumbs": [
      "Datenstrukturen",
      "Kodierschema"
    ]
  },
  {
    "objectID": "data-structures/coding-scheme.html#page",
    "href": "data-structures/coding-scheme.html#page",
    "title": "Kodierschema",
    "section": "page",
    "text": "page\nSollte der Player die Unit auf verschiedene Seiten verteilen, dient dies normalerweise dem Verteilen eines umfangreichen Inhaltes auf u. U. nicht sichtbare Bereich. Es ist dann ein Blättern nötig, um alle Interaktionselemente zu erreichen. Bei der Kodierung ist es sehr hilfreich, wenn man beim Replay – also der Anzeige des letzten Standes der Beantwortung – gleich zur richtigen Seite der Variablen springt und nicht erst blättern muss. Ein leerer Eintrag ''bedeutet, dass es entweder nur eine Seite gibt oder dass die Variable nicht verlässlich einer Seite zugeordnet werden kann (z. B. bei abgeleiteten Variablen).",
    "crumbs": [
      "Datenstrukturen",
      "Kodierschema"
    ]
  },
  {
    "objectID": "data-structures/coding-scheme.html#id-1",
    "href": "data-structures/coding-scheme.html#id-1",
    "title": "Kodierschema",
    "section": "id",
    "text": "id\nDies ist der Wert, der als Ergebnis der Kodierung dem Parameter code der Antwortdaten zugewiesen wird. Es handelt sich um einen numerischen ganzahligen Wert.\nDiese id kann auch den Wert null annehmen. Dann bleiben die Parameter code und score gleich 0, aber der Parameter status wird auf den Wert INVALID gesetzt. Es sind dann also Bedingungen beschrieben, die die Antwort als ungültig klassifizieren sollen. Beispiel: Eine alternative Auswahl hat 4 Optionen. Dann kann man für diese vier Optionen reguläre Codes 1-4 vorsehen, und eine abweichende Antwort (‘Alle anderen Antworten’) ist ungültig. Damit ist das Kodierschema ‘geschlossen’, d. h. es gibt immer ein eindeutiges Ergebnis.\n\n\n\n\n\n\nGefahr von Verschleiern eines Problems\n\n\n\nWenn ein eigentlich unmöglicher Wert mit INVALID markiert wird, könnte ein ernstes Problem in der Datenverarbeitung oder im Player dahinter stecken. Derartige Fälle sollten stets genauer untersucht werden.",
    "crumbs": [
      "Datenstrukturen",
      "Kodierschema"
    ]
  },
  {
    "objectID": "data-structures/coding-scheme.html#type",
    "href": "data-structures/coding-scheme.html#type",
    "title": "Kodierschema",
    "section": "type",
    "text": "type\nÜber den Typ RESIDUAL_AUTO kann festgelegt werden, dass eine Kodierung abgeschlossen wird: Alle anderen Codes werden über Regeln geprüft, und wenn keiner zutrifft, wird die Code-Id mit diesem Typ zugewiesen. Die anderen Code-Typen haben keine Auswirkung auf die automatische Kodierung, sondern steuern nach bestimmten Konventionen nachgelagerte Arbeitsschritte oder die Darstellung beim Editieren oder Kodieren:\n\n\n\n\n\n\n\n\n\n\nTyp\nErläuterung\nStandard-Label\nStandard-Id\nStandard-Score\n\n\n\n\nFULL_CREDIT\nEine vollständig richtige Antwort.\nrichtig\n1 bzw. 11, 12, usw.\n1\n\n\nPARTIAL_CREDIT\nEine teilweise richtige Antwort.\nteilweise richtig\n2 bzw. 21, 22, usw.\n0\n\n\nTO_CHECK\nDiese Antwortkategorie ist noch nicht final beschlossen.\nzu prüfen\n3 bzw. 31, 32, usw.\n0\n\n\nNO_CREDIT\nEine falsche Antwort.\nfalsch\n4 bzw. 41, 42, usw.\n0\n\n\nUNSET\nEs soll kein Code-Typ angewendet werden\n(manuell festzugelegen)\nkeine Konvention\n0\n\n\nRESIDUAL\nAlle anderen Antworten\nfalsch\n0\n0",
    "crumbs": [
      "Datenstrukturen",
      "Kodierschema"
    ]
  },
  {
    "objectID": "data-structures/coding-scheme.html#label-1",
    "href": "data-structures/coding-scheme.html#label-1",
    "title": "Kodierschema",
    "section": "label",
    "text": "label\nDieser Parameter kann eine Kurzfassung der Regeln und Instruktionen enthalten und soll darüber für den Code eine Orientierung geben in Listen.",
    "crumbs": [
      "Datenstrukturen",
      "Kodierschema"
    ]
  },
  {
    "objectID": "data-structures/coding-scheme.html#score",
    "href": "data-structures/coding-scheme.html#score",
    "title": "Kodierschema",
    "section": "score",
    "text": "score\nWenn der Code zutrifft, wird auch stets der Parameter score der Antwortdaten gesetzt. Es handelt sich um einen numerischen ganzahligen Wert.",
    "crumbs": [
      "Datenstrukturen",
      "Kodierschema"
    ]
  },
  {
    "objectID": "data-structures/coding-scheme.html#manualinstruction-1",
    "href": "data-structures/coding-scheme.html#manualinstruction-1",
    "title": "Kodierschema",
    "section": "manualInstruction",
    "text": "manualInstruction\nHier sind Instruktionen an eine reale Person gespeichert, die nach Sichtung der Antwort manuell einen Code vergeben soll. Dies kann auch ergänzend zu Regeln sein: Für Standardfälle werden Regeln definiert, die eine automatische Kodierung – soweit möglich – vornehmen, und erst wenn kein Code gefunden wurde, muss eine Person manuell evaluieren. Hierbei ist darauf zu achten, dass keine Regel ‘Alle anderen Antworten’ hinterlegt ist, da sonst dieser Code automatisch vergeben wird und nicht CODING_INCOMPLETE.\nDieser Text kann Html-Formatierungen enthalten. Dazu gehören auch Bilder, die dann über die Binärkodierung base64 eingebettet sind.\n\n\n\n\n\n\nSicherheitshinweis\n\n\n\nBei der Anzeige dieser Texte ist stets darauf zu achten, dass Code entfernt wird (über sog. HTML Sanitizer). Ein Verzicht darauf würde eine Sicherheitslücke bedeuten.",
    "crumbs": [
      "Datenstrukturen",
      "Kodierschema"
    ]
  },
  {
    "objectID": "data-structures/coding-scheme.html#rulesetoperatorand",
    "href": "data-structures/coding-scheme.html#rulesetoperatorand",
    "title": "Kodierschema",
    "section": "ruleSetOperatorAnd",
    "text": "ruleSetOperatorAnd\nWenn dieser boolesche Wert true ist, dann werden die Ergebnisse der Regelsätze mit UND verknüpft. Alle Regelsätze müssen true liefern, damit der Code als zutreffend bewertet wird. Bei false reicht es, dass ein Regelsatz true ergibt (ODER-Verknüpfung).",
    "crumbs": [
      "Datenstrukturen",
      "Kodierschema"
    ]
  },
  {
    "objectID": "data-structures/coding-scheme.html#rulesets",
    "href": "data-structures/coding-scheme.html#rulesets",
    "title": "Kodierschema",
    "section": "ruleSets",
    "text": "ruleSets\nRegelsätze fassen mehrere Regeln zusammen in einer Gruppe. Ein Regelsatz hat folgende Parameter:\n\nvalueArrayPos: Sollte der Antwortwert eine Liste von Werten sein,\n\nstellt dieser Parameter einen Bezug zu einer bestimmten Position im Array her (Datentyp Integer 0..n-1), oder\nsoll mindestens ein Wert im Array gefunden werden, der die Bedingungen erfüllt (Datentyp String ANY oder ANY_OPEN; letzteres legt fest, dass im Array auch andere Werte vorhanden sein dürfen außer denen, für die das Regelset zutrifft), oder\nsollen vor der Auswertung alle Array-Werte bzw. alle Fragmente als numerische Werte interpretiert und summiert werden (Datentyp String SUM), oder\nsoll vor der Auswertung die Anzahl der Array-Werte ermittelt werden (Datentyp String LENGTH)\n\nruleOperatorAnd: Wenn dieser boolesche Wert true ist, dann werden die Ergebnisse der Regeln mit UND verknüpft. Alle Regeln müssen true liefern, damit der Code als zutreffend bewertet wird. Bei false reicht es, dass eine Regel true ergibt (ODER-Verknüpfung).",
    "crumbs": [
      "Datenstrukturen",
      "Kodierschema"
    ]
  },
  {
    "objectID": "data-structures/coding-scheme.html#rules",
    "href": "data-structures/coding-scheme.html#rules",
    "title": "Kodierschema",
    "section": "rules",
    "text": "rules\nRegeln sind Vorschriften, die jeweils einen Wert analysieren nach einem vorgegebenen Muster. Die Anwendung einer Regel liefert stets ein ‘Match’, also ob ein Wert einer bestimmten Erwartung entspricht.\n\nfragment: Das Kodierschema für eine Variable kann im Parameter fragmenting einen regulären Ausdruck enthalten, der einen Wert in mehrere Teile zerlegt (s. o.). Eine Regel kann sich über den Parameter fragment (Datentyp Integer) auf ein bestimmtes Fragment beziehen. Es wird eine ganze positive Zahl als Array-Position erwartet oder ‘-1’ dafür, dass irgendein Fragment die Bedingung erfüllen muss.\nmethod:\n\nMATCH: Es wird eine Übereinstimmung geprüft (String-Vergleich). Hierfür ist EIN Parameter nötig (s. u.). Ist der Parameterwert mehrzeilig, wird pro Zeile die Übereinstimmung geprüft.\nMATCH_REGEX: Es wird eine Übereinstimmung geprüft (String-Vergleich über regulären Ausdruck). Hierfür ist EIN Parameter nötig (s. u.). Ist der Parameterwert mehrzeilig, wird pro Zeile die Übereinstimmung geprüft. Es wird die JavaScript-Funktion match() verwendet, wobei ein Ergebnis ungleich null als positiv gewertet wird.\nNUMERIC_MATCH: Es wird eine Übereinstimmung geprüft. Hierfür ist EIN Parameter nötig (s. u.). Ist der Parameterwert mehrzeilig, wird pro Zeile die Übereinstimmung geprüft. Wert und Vergleichswert werden vor der Prüfung in einen numerischen Wert transformiert. Eventuell vorhandene Leerzeichen werden vorher komplett entfernt, und ein Komma wird ggf. durch einen Dezimalpunkt ersetzt.\nNUMERIC_RANGE: Es wird geprüft, ob der Wert im Bereich “min &lt; Wert &lt;= max” liegt. Hierfür sind ZWEI Parameter nötig (s. u.). Die Aufbereitung der Werte siehe NUMERIC_MATCH.\nNUMERIC_LESS_THAN: Es wird geprüft, ob der Wert kleiner als der Parameterwert ist. Hierfür ist EIN Parameter nötig (s. u.). Die Aufbereitung der Werte siehe NUMERIC_MATCH.\nNUMERIC_MORE_THAN: Es wird geprüft, ob der Wert größer als der Parameterwert ist. Hierfür ist EIN Parameter nötig (s. u.). Die Aufbereitung der Werte siehe NUMERIC_MATCH.\nNUMERIC_MAX: Es wird geprüft, ob der Wert höchstens der Parameterwert ist. Hierfür ist EIN Parameter nötig (s. u.). Die Aufbereitung der Werte siehe NUMERIC_MATCH.\nNUMERIC_MIN: Es wird geprüft, ob der Wert mindestens der Parameterwert ist. Hierfür ist EIN Parameter nötig (s. u.). Die Aufbereitung der Werte siehe NUMERIC_MATCH.\nIS_EMPTY: Prüft, ob der Wert leer ist. Wenn es sich um eine Basisvariable handelt, die kein Array ist, muss bei sourceParameter/processing der Schalter TAKE_EMPTY_AS_VALID gesetzt sein, damit die leere Antwort ausgewertet wird. Diese Regel sollte im ersten Code platziert sein, da andere Regeln u. U. einen CODING_ERROR erzeugen, wenn der Antwortwert leer ist.\nELSE: Diese Regel bezieht sich nicht auf einen bestimmten Wert, sondern trifft immer zu. Sie prüft nichts, sondern der Code, der diese Regel enthält, wird als zutreffend evaluiert. Sie sollte also im letzten Code definiert sein, wenn das Kodierschema geschlossen werden soll.\nIS_NULL: Prüft, ob der Wert null ist im Sinne der Datentypdefinition von JavaScript. Diese Regel sollte im ersten Code platziert sein, da andere Regeln u. U. einen CODING_ERROR erzeugen, wenn der Antwortwert null ist.\nIS_TRUE, IS_FALSE: Prüft, ob der Wert wahr bzw. falsch ist.\n\nparameters: Einige Regeln benötigen einen Parameter, eine sogar zwei. Diese Parameter werden hier gespeichert. Der Datentyp ist eine Liste (Array) von Strings.",
    "crumbs": [
      "Datenstrukturen",
      "Kodierschema"
    ]
  },
  {
    "objectID": "data-structures/itc-ToolBox-Output/index.html",
    "href": "data-structures/itc-ToolBox-Output/index.html",
    "title": "Output der itc-ToolBox",
    "section": "",
    "text": "Achtung: Datenformate in Entwicklung\n\n\n\nAktuell ist die Version 2.0 der itc-ToolBox noch nicht veröffentlicht. Die nachfolgenden Spezifikationen dienen der IQB-internen Diskussion.\n\n\nMit der Version 2.0 wurde die Aufarbeitung der Testcenter-Ergebnisse durch die Windows-Anwendung itc-ToolBox überarbeitet. Dies wurde notwendig, weil die steigende Zahl der Antwortdaten die Ausführung stark behinderte (Abstürze Out-Of-Memory) und mit Fortschreiten der Entwicklungsarbeiten an der IQB-Kodierbox der Bedarf an der Spezifikation weiterer Datenformate und Schnittstellen stieg.\nDas Format “TC-Merge” steht für die Verbindung der Datenproduktion im IQB-Testcenter mit der Datenprüfung und -verarbeitung. Die zeitlich unregelmäßig anfallenden Daten werden nach Ende der Testung bzw. Befragung so strukturiert, dass eine Verarbeitung gefördert wird. Bei großen Datenmengen kann man dann ersteinmal die Daten ohne Verlust speichern.\n\n\n\n\n\nflowchart TD\n    TB[itc-ToolBox] &lt;--&gt; M(TC-Merge)\n    TB[itc-ToolBox] &lt;--&gt; BS(Testheft-Größen)\n    style M fill:yellow\n    style TB fill:yellow\n    style BS fill:yellow\n    CSV[CSV-Datei] --&gt; TB\n    TC[IQB-Testcenter] --&gt; TB\n    TC --&gt; CSV\n    TB --&gt; RC(Antworten kompakt)\n    TB --&gt; J(Journal)\n    TB --&gt; S(Statistik)\n\n\n\n\n\n\n\nFormat “TC-Merge”\nBevor irgendeine Prüfung oder Verarbeitung von Daten stattfinden kann, müssen sie zunächst zusammengeführt werden. Dieses sog. Merging nimmt die Daten aus verschiedenen Quellen zusammen, ohne sie zu prüfen. Es sind dann u. U. Dopplungen gespeichert, die durch Fehler im Datenmanagement verursacht werden, oder es werden völlig uninteressante Variablen übernommen, obwohl sie nie Werte enthalten.\nDie itc-ToolBox übernimmt Daten aus folgenden Quellen:\n\nCSV-Dateien: Als Administrator*in eines Arbeitsbereiches einer IQB-Testcenterinstallation kann man jederzeit Antworten und Logs als CSV-Dateien speichern. Dies empfiehlt sich z. B., um Datenverlust vorzubeugen. Es ist aber auch die einzige Möglichkeit, Daten von IQB-Testcenterinstallationen zu erhalten, die in Offline-Szenarien eingesetzt wurden. Diese Laptops sind nicht online, sondern fungieren lokal z. B. in einer Schule ohne Internet-Anbindung als Server.\nIQB-Testcenter: Die itc-ToolBox kann direkt auf eine IQB-Testcenterinstallation zugreifen und nach einer Anmeldung Daten herunterladen. Der Zugriff erzeugt dabei keine CSV-Dateien, sondern nutzt einen JSON-Endpunkt der API.\n\nDas erzeugte Datenformat ist hier spezifiziert. Es handelt sich nicht um Tabellen wie CSV oder Xlsx, sondern um eine Folge von strukturierten Objekten im JSON-Format.\n\n\n\n\n\nflowchart LR\n    BS[Testheft-Größen]\n    style BS fill:white\n    P[Person] --&gt; B[Testheft]\n    B --&gt; BL[Testheft-Logs]\n    B --&gt; U[Unit]\n    U --&gt; R[Antworten]\n    U --&gt; UL[Unit-Logs]\n    U --&gt; Ch[Antwort-Blöcke]\n    B --&gt; S[Sessions]\n    Big[Große Antworten]\n    style Big fill:white\n\n\n\n\n\n\nFolgende Umformungen nimmt die itc-ToolBox vor:\n\nLogs werden den Booklets und den Units zugeordnet.\nDer Value-Datentyp einer Antwort ist stets String.\nEs werden einem Booklet die Ladeprozesse als Session zugeordnet. Dadurch ist erkennbar, ob während der Beantwortung ein Restart erfolgte.\nDie Daten zu Betriebssystem, Browser und Monitor werden aus dem Log extrahiert und der Session zugeordnet.\nEs werden die Größen der Testhefte ausgelesen, um später die Qualität der einzelnen Verbindungen schätzen zu können.\nGroße Dateien: Wird im Value ein Objekt application/octet-stream;base64 erkannt, kann es als separate Datei gespeichert werden (z. B. GeoGebra). Dadurch wird die Datenverarbeitung entlastet.\n\n\n\nTestheft-Größen\nDies ist eine kleine JSON-Datei, die für jedes Booklet dessen Größe in Byte enthält. Dies kann verwendet werden, um mithilfe der Ladezeiten die Geschwindigkeit der Verbindung zu ermitteln.\n\n\nFormat “Antworten kompakt”\n(in Vorbereitung)\n\nEntfernen aller Logs und Sessions\nEntfernen aller Variablen, die nicht den Status VALUE_CHANGED haben\nEntfernen des Status-Wertes\nIgnorieren aller Objekte application/octet-stream;base64\n\n\n\nFormat “Journal”\n(in Vorbereitung)\nDarstellung des Testablaufes für alle Testpersonen x Booklet\n\n(u. U. mehrmaliger) Start mit Ladezeit\nNavigation durch die Units\nVerweilzeiten auf Seiten (Time-On-Page)\nVerlassen und Rückkehr (Got/Lost Focus)\n\n\n\nFormat “Statistik”\n(in Vorbereitung)\nDarstellung einiger Indikatoren über alle Testpersonen hinweg.",
    "crumbs": [
      "Datenstrukturen",
      "itc-ToolBox Output"
    ]
  },
  {
    "objectID": "data-structures/index.html",
    "href": "data-structures/index.html",
    "title": "Datenstrukturen",
    "section": "",
    "text": "Sicht der Datenanalyse\nWenn Datenanalysen durchgeführt werden, benötigen sie im Kern eine zweidimensionale Matrix der Antwortdaten Testperson x Item. Die Testperson wird durch eine ID gekennzeichnet, das Item hat ebenfalls eine ID, und im Kreuzungspunkt findet sich ein Wert, der die Antwort der Testperson repräsentiert. Dann kann man Unterschiede der Personen und der Items analysieren.\nBei der Analyse spielen außerdem zusätzliche Daten eine Rolle, die entweder die Person oder die Items näher beschreiben. So ist z. B. wichtig, in welchem sozioökonomischen Umfeld sich die Schule der Testperson befindet, an welcher Stelle des Testheftes das Item auftauchte oder wie schwer dieses Item ist. Die folgende Grafik veranschaulicht grob eine solche Datenstruktur.\n\n\n\n\n\nclassDiagram\n    direction LR\n    class StudentGroup{\n        String: ID\n        String: Testgruppe\n        List~any~: Metadaten\n    }\n    class Student{\n        String: ID\n        String: Testgruppe\n        List~any~: Metadaten\n    }\n    class Booklet{\n        String: ID\n        String: Label\n        List~any~: Metadaten\n    }\n    class Unit{\n        String: ID\n        String: Label\n        List~any~: Metadaten\n    }\n    class Item{\n        String: ID\n        List~any~: Metadaten\n        int: Value\n    }\n    StudentGroup \"1..*\" &lt;--&gt; \"1..*\" Student\n    Student \"1\" --&gt; \"1..*\" Booklet\n    Booklet \"1\" --&gt; \"1..*\" Unit\n    Unit \"1\" --&gt; \"1..*\" Item\n\n\n\n\n\n\nFür diese Dokumentation spielt dies allerdings keine Rolle. Alle Texte beziehen sich auf die Frage, wo der Wert für das Item herkommt.\n\n\nSicht des Testsystems\nDie Quelle für die Antworten sind vor allem die Interaktionselemente der Aufgabe (Eingabefelder, Ankreuzkästchen, Ablegelisten usw.). Außerdem können Ereignisse (zeitbezogene Zustandsänderungen) Informationen liefern, die in Variablen gespeichert werden (Logvariablen).\n\n\n\n\n\nflowchart TD\n    subgraph Unit\n        subgraph Testdurchführung\n            A(Basisvariablen)\n            style A fill:white\n            B(Logvariablen)\n            style B fill:white\n        end\n        style Testdurchführung fill:#b3b3cc\n        E[Kodierung\\nAbleitung]\n        style E fill:#ff9\n        C(Kodierschema)\n        style C fill:white\n        J(Itemliste)\n        style J fill:white\n    end\n    style Unit fill:#e0e0eb\n    H(Person)\n    style H fill:white\n    D[Primärdatensatz]\n    H--&gt;D\n    E --&gt; D\n    A --&gt; E\n    B --&gt; E\n    C --&gt; E\n    G[Analysedatensatz\\nPerson x Item]\n    D --&gt; G\n    F(Missingschema) --&gt; G\n    style F fill:white\n    K(Unitposition\\nim Testheft) --&gt; G\n    style K fill:white\n    J --&gt; G\n    L(Metadaten\\naus versch. Quellen) --&gt; G\n    style L fill:white\n\n\n\n\n\n\nDie Antworten werden in einer einheitlichen Datenstruktur “Variable” gespeichert. Neben dem Antwortwert ist hier eine Information zum Status (State) zu finden, also ob z. B. das Interaktionselement gesehen wurde, ob eine Bearbeitung stattgefunden hat usw.\nEin Kodierschema enthält alle Informationen für die manuelle oder automatische Kodierung. Die States der Variablen im Kodierprozess wird über eine State-Änderung angezeigt, und nach Abschluss der Kodierung sind die Werte “Code” und “Score” für die Variable gesetzt.\n\n\nItemwert\nZunächst besteht der Itemwert aus dem Score-Wert einer Variablen. Für jedes Item ist hierzu in einer Itemliste eine Variable benannt. Dies kann eine Basisvariable oder eine abgeleitete Variable sein. Der Score-Wert ergibt sich nach der Kodierung, also nach der vollständigen Anwendung des Kodierschemas. Üblicherweise handelt es sich bei dem Scorewert um eine ganze Zahl, i. d. R. 0 oder 1.\nSollten allerdings für die Itemvariable keine gültigen Antwortwerte vorliegen, wird eine negative Zahl für den Itemwert gesetzt. Diese Zahl symbolisiert nach einer allgemeinen Konvention verschiedene Missing-Zustände, die nicht nur aus den Antworten einer Unit ermittelt werden können, sondern zusätzliche Informationen erfordern.\nIn der Tradition der Kompetenzdiagnostik werden zwar zunächst Analysen gerechnet, später jedoch die Missing-Werte rekodiert: Zu 0 = falsch oder zu einem allgemeinen Missing-Wert, der vom verwendeten Analysesystem abhängt (sog. sysmis).",
    "crumbs": [
      "Datenstrukturen"
    ]
  }
]