[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Kodieren",
    "section": "",
    "text": "Willkommen\nIn Studien zur Feststellung von Leistungsständen im Bildungswesen liegt der Arbeitsschritt “Kodieren” zwischen der Datenerhebung - also der Durchführung eines Assessments - und der Datenanalyse. Rohantworten führen zu komplexen Datenstrukturen mit einem großen Wertespektrum, die so kaum auswertbar sind. Kodierung heißt hier, diese Werte einfachen Kategorien (“Codes”) zuzuordnen, die die Antwort im Sinne der Studienzielstellung symbolisieren. Anschließend lassen sich Häufigkeiten für diese Kategorien ermitteln, Zusammenhänge modellieren, und letztlich können empirisch begründete Empfehlungen gegeben werden.\nMit der schrittweisen Nutzung von Computern für Leistungserhebungen eröffnen sich neue Möglichkeiten, die Kodierung zu automatisieren und zu standardisieren. Hierzu entwickelt das IQB Datenstrukturen und Prozesse, die auf diesen Webseiten beschrieben sind.\n\n\nLizenz\nAlle Texte sind unter der Lizenz CC0 veröffentlicht. Die Leitlinien zur Sicherung guter wissenschaftlicher Praxis (s. z. B. DFG-pdf) gebieten gleichwohl, dass die Quellen von Informationen genannt werden sollten.\n\n\nHaftungsausschluss\nAuf diesen Webseiten sind Links auf externe Webseiten in besonderer Weise gekennzeichnet (s. oben die Links zum IQB und zur KMK). Wir prüfen diese Quellen regelmäßig, können aber für diese Seiten und die dort hinterlegten Zusatzmaterialien keine Haftung für Richtigkeit, Vollständigkeit und Aktualität übernehmen. Dafür sind ausschließlich deren Betreiber verantwortlich.\n\n\nTechnische Realisierung\nDieser Webauftritt basiert auf Texten in einer einfachen Syntax Markdown, die anschließend in Html und CSS umgesetzt werden. Hierzu wird Quarto verwendet. Sämtliche Dateien für den Inhalt und die Steuerung sind in einem öffentlich zugänglichen Codeverwaltungssystem gespeichert.\n\n\nKontakt\nTechnische und inhaltliche Fragen zu den Inhalten können Sie an die IT des IQB richten.\nWenn Sie Probleme melden möchten, können Sie auch die Funktion “Problem melden” nutzen, die rechts auf jeder Seite zu finden ist. Sie werden dann zu GitHub weitergeleitet. Es ist ein Account bei GitHub erforderlich.",
    "crumbs": [
      "Start"
    ]
  },
  {
    "objectID": "data-structures/index.html",
    "href": "data-structures/index.html",
    "title": "Datenstrukturen",
    "section": "",
    "text": "Sicht der Datenanalyse\nWenn Datenanalysen durchgeführt werden, benötigen sie im Kern eine zweidimensionale Matrix der Antwortdaten Testperson x Item. Die Testperson wird durch eine ID gekennzeichnet, das Item hat ebenfalls eine ID, und im Kreuzungspunkt findet sich ein Wert, der die Antwort der Testperson repräsentiert. Dann kann man Unterschiede der Personen und der Items analysieren.\nBei der Analyse spielen außerdem zusätzliche Daten eine Rolle, die entweder die Person oder die Items näher beschreiben. So ist z. B. wichtig, in welchem sozioökonomischen Umfeld sich die Schule der Testperson befindet, an welcher Stelle des Testheftes das Item auftauchte oder wie schwer dieses Item ist. Die folgende Grafik veranschaulicht grob eine solche Datenstruktur.\n\n\n\n\n\nclassDiagram\n    direction LR\n    class StudentGroup{\n        String: ID\n        String: Testgruppe\n        List~any~: Metadaten\n    }\n    class Student{\n        String: ID\n        String: Testgruppe\n        List~any~: Metadaten\n    }\n    class Booklet{\n        String: ID\n        String: Label\n        List~any~: Metadaten\n    }\n    class Unit{\n        String: ID\n        String: Label\n        List~any~: Metadaten\n    }\n    class Item{\n        String: ID\n        List~any~: Metadaten\n        int: Value\n    }\n    StudentGroup \"1..*\" &lt;--&gt; \"1..*\" Student\n    Student \"1\" --&gt; \"1..*\" Booklet\n    Booklet \"1\" --&gt; \"1..*\" Unit\n    Unit \"1\" --&gt; \"1..*\" Item\n\n\n\n\n\n\nFür diese Dokumentation spielt dies allerdings keine Rolle. Alle Texte beziehen sich auf die Frage, wo der Wert für das Item herkommt.\n\n\nSicht des Testsystems\nDie Quelle für die Antworten sind vor allem die Interaktionselemente der Aufgabe (Eingabefelder, Ankreuzkästchen, Ablegelisten usw.). Außerdem können Ereignisse (zeitbezogene Zustandsänderungen) Informationen liefern, die in Variablen gespeichert werden (Logvariablen).\n\n\n\n\n\nflowchart TD\n    subgraph Unit\n        subgraph Testdurchführung\n            A(Basisvariablen)\n            style A fill:white\n            B(Logvariablen)\n            style B fill:white\n        end\n        style Testdurchführung fill:#b3b3cc\n        E[Kodierung\\nAbleitung]\n        style E fill:#ff9\n        C(Kodierschema)\n        style C fill:white\n        J(Itemliste)\n        style J fill:white\n    end\n    style Unit fill:#e0e0eb\n    H(Person)\n    style H fill:white\n    D[Primärdatensatz]\n    H--&gt;D\n    E --&gt; D\n    A --&gt; E\n    B --&gt; E\n    C --&gt; E\n    G[Analysedatensatz\\nPerson x Item]\n    D --&gt; G\n    F(Missingschema) --&gt; G\n    style F fill:white\n    K(Unitposition\\nim Testheft) --&gt; G\n    style K fill:white\n    J --&gt; G\n    L(Metadaten\\naus versch. Quellen) --&gt; G\n    style L fill:white\n\n\n\n\n\n\nDie Antworten werden in einer einheitlichen Datenstruktur “Variable” gespeichert. Neben dem Antwortwert ist hier eine Information zum Status (State) zu finden, also ob z. B. das Interaktionselement gesehen wurde, ob eine Bearbeitung stattgefunden hat usw.\nEin Kodierschema enthält alle Informationen für die manuelle oder automatische Kodierung. Die States der Variablen im Kodierprozess wird über eine State-Änderung angezeigt, und nach Abschluss der Kodierung sind die Werte “Code” und “Score” für die Variable gesetzt.\n\n\nItemwert\nZunächst besteht der Itemwert aus dem Score-Wert einer Variablen. Für jedes Item ist hierzu in einer Itemliste eine Variable benannt. Dies kann eine Basisvariable oder eine abgeleitete Variable sein. Der Score-Wert ergibt sich nach der Kodierung, also nach der vollständigen Anwendung des Kodierschemas. Üblicherweise handelt es sich bei dem Scorewert um eine ganze Zahl, i. d. R. 0 oder 1.\nSollten allerdings für die Itemvariable keine gültigen Antwortwerte vorliegen, wird eine negative Zahl für den Itemwert gesetzt. Diese Zahl symbolisiert nach einer allgemeinen Konvention verschiedene Missing-Zustände, die nicht nur aus den Antworten einer Unit ermittelt werden können, sondern zusätzliche Informationen erfordern.\nIn der Tradition der Kompetenzdiagnostik werden zwar zunächst Analysen gerechnet, später jedoch die Missing-Werte rekodiert: Zu 0 = falsch oder zu einem allgemeinen Missing-Wert, der vom verwendeten Analysesystem abhängt (sog. sysmis).",
    "crumbs": [
      "Datenstrukturen"
    ]
  },
  {
    "objectID": "data-structures/itc-ToolBox-Output/index.html",
    "href": "data-structures/itc-ToolBox-Output/index.html",
    "title": "Output der itc-ToolBox",
    "section": "",
    "text": "Achtung: Datenformate in Entwicklung\n\n\n\nAktuell ist die Version 2.0 der itc-ToolBox noch nicht veröffentlicht. Die nachfolgenden Spezifikationen dienen der IQB-internen Diskussion.\n\n\nMit der Version 2.0 wurde die Aufarbeitung der Testcenter-Ergebnisse durch die Windows-Anwendung itc-ToolBox überarbeitet. Dies wurde notwendig, weil die steigende Zahl der Antwortdaten die Ausführung stark behinderte (Abstürze Out-Of-Memory) und mit Fortschreiten der Entwicklungsarbeiten an der IQB-Kodierbox der Bedarf an der Spezifikation weiterer Datenformate und Schnittstellen stieg.\nDas Format “TC-Merge” steht für die Verbindung der Datenproduktion im IQB-Testcenter mit der Datenprüfung und -verarbeitung. Die zeitlich unregelmäßig anfallenden Daten werden nach Ende der Testung bzw. Befragung so strukturiert, dass eine Verarbeitung gefördert wird. Bei großen Datenmengen kann man dann ersteinmal die Daten ohne Verlust speichern.\n\n\n\n\n\nflowchart TD\n    TB[itc-ToolBox] &lt;--&gt; M(TC-Merge)\n    TB[itc-ToolBox] &lt;--&gt; BS(Testheft-Größen)\n    style M fill:yellow\n    style TB fill:yellow\n    style BS fill:yellow\n    CSV[CSV-Datei] --&gt; TB\n    TC[IQB-Testcenter] --&gt; TB\n    TC --&gt; CSV\n    TB --&gt; RC(Antworten kompakt)\n    TB --&gt; J(Journal)\n    TB --&gt; S(Statistik)\n\n\n\n\n\n\n\nFormat “TC-Merge”\nBevor irgendeine Prüfung oder Verarbeitung von Daten stattfinden kann, müssen sie zunächst zusammengeführt werden. Dieses sog. Merging nimmt die Daten aus verschiedenen Quellen zusammen, ohne sie zu prüfen. Es sind dann u. U. Dopplungen gespeichert, die durch Fehler im Datenmanagement verursacht werden, oder es werden völlig uninteressante Variablen übernommen, obwohl sie nie Werte enthalten.\nDie itc-ToolBox übernimmt Daten aus folgenden Quellen:\n\nCSV-Dateien: Als Administrator*in eines Arbeitsbereiches einer IQB-Testcenterinstallation kann man jederzeit Antworten und Logs als CSV-Dateien speichern. Dies empfiehlt sich z. B., um Datenverlust vorzubeugen. Es ist aber auch die einzige Möglichkeit, Daten von IQB-Testcenterinstallationen zu erhalten, die in Offline-Szenarien eingesetzt wurden. Diese Laptops sind nicht online, sondern fungieren lokal z. B. in einer Schule ohne Internet-Anbindung als Server.\nIQB-Testcenter: Die itc-ToolBox kann direkt auf eine IQB-Testcenterinstallation zugreifen und nach einer Anmeldung Daten herunterladen. Der Zugriff erzeugt dabei keine CSV-Dateien, sondern nutzt einen JSON-Endpunkt der API.\n\nDas erzeugte Datenformat ist hier spezifiziert. Es handelt sich nicht um Tabellen wie CSV oder Xlsx, sondern um eine Folge von strukturierten Objekten im JSON-Format.\n\n\n\n\n\nflowchart LR\n    BS[Testheft-Größen]\n    style BS fill:white\n    P[Person] --&gt; B[Testheft]\n    B --&gt; BL[Testheft-Logs]\n    B --&gt; U[Unit]\n    U --&gt; R[Antworten]\n    U --&gt; UL[Unit-Logs]\n    U --&gt; Ch[Antwort-Blöcke]\n    B --&gt; S[Sessions]\n    Big[Große Antworten]\n    style Big fill:white\n\n\n\n\n\n\nFolgende Umformungen nimmt die itc-ToolBox vor:\n\nLogs werden den Booklets und den Units zugeordnet.\nDer Value-Datentyp einer Antwort ist stets String.\nEs werden einem Booklet die Ladeprozesse als Session zugeordnet. Dadurch ist erkennbar, ob während der Beantwortung ein Restart erfolgte.\nDie Daten zu Betriebssystem, Browser und Monitor werden aus dem Log extrahiert und der Session zugeordnet.\nEs werden die Größen der Testhefte ausgelesen, um später die Qualität der einzelnen Verbindungen schätzen zu können.\nGroße Dateien: Wird im Value ein Objekt application/octet-stream;base64 erkannt, kann es als separate Datei gespeichert werden (z. B. GeoGebra). Dadurch wird die Datenverarbeitung entlastet.\n\n\n\nTestheft-Größen\nDies ist eine kleine JSON-Datei, die für jedes Booklet dessen Größe in Byte enthält. Dies kann verwendet werden, um mithilfe der Ladezeiten die Geschwindigkeit der Verbindung zu ermitteln.\n\n\nFormat “Antworten kompakt”\n(in Vorbereitung)\n\nEntfernen aller Logs und Sessions\nEntfernen aller Variablen, die nicht den Status VALUE_CHANGED haben\nEntfernen des Status-Wertes\nIgnorieren aller Objekte application/octet-stream;base64\n\n\n\nFormat “Journal”\n(in Vorbereitung)\nDarstellung des Testablaufes für alle Testpersonen x Booklet\n\n(u. U. mehrmaliger) Start mit Ladezeit\nNavigation durch die Units\nVerweilzeiten auf Seiten (Time-On-Page)\nVerlassen und Rückkehr (Got/Lost Focus)\n\n\n\nFormat “Statistik”\n(in Vorbereitung)\nDarstellung einiger Indikatoren über alle Testpersonen hinweg.",
    "crumbs": [
      "Datenstrukturen",
      "itc-ToolBox Output"
    ]
  },
  {
    "objectID": "data-structures/coding-scheme.html",
    "href": "data-structures/coding-scheme.html",
    "title": "Kodierschema",
    "section": "",
    "text": "Auf dieser Seite sind in komprimierter Form alle Parameter und möglichen Werte eines Kodierschemas beschrieben. Andere Quellen:",
    "crumbs": [
      "Datenstrukturen",
      "Kodierschema"
    ]
  },
  {
    "objectID": "data-structures/coding-scheme.html#id",
    "href": "data-structures/coding-scheme.html#id",
    "title": "Kodierschema",
    "section": "id",
    "text": "id\nDie möglichen Werte hier sind recht weit gefasst. Es sind zwar nur Buchstaben, Ziffern und ’_’ erlaubt, aber es gibt keine Mindestlänge und die ID kann nur aus Ziffern bestehen.\nAls Quelle der Variablen-ID fungieren zunächst die Basisvariablen – also die Variablen, die als Interaktionselemente in der Unit-Definition angelegt sind. Darüber hinaus können abgeleitete Variablen Teil des Kodierschemas sein, deren ID lediglich eindeutig innerhalb der Liste sein muss.",
    "crumbs": [
      "Datenstrukturen",
      "Kodierschema"
    ]
  },
  {
    "objectID": "data-structures/coding-scheme.html#alias",
    "href": "data-structures/coding-scheme.html#alias",
    "title": "Kodierschema",
    "section": "alias",
    "text": "alias\nEin Alias ist eine alternative ID, die durch User vergeben werden kann. Dann kann die ID der Variable nicht mehr geändert werden und bleibt konstant über alle Verarbeitungsschritte und Versionen. Der Alias kann aber nach Bedarf geändert werden. Das IQB hat diese Trennung eingeführt, als sich Umbenennungen von Variablen häuften und jede Umbenennung Inkonsistenzen verursachte (Ableitungen schlugen fehl, Seitenzustände wurden falsch ermittelt).",
    "crumbs": [
      "Datenstrukturen",
      "Kodierschema"
    ]
  },
  {
    "objectID": "data-structures/coding-scheme.html#label",
    "href": "data-structures/coding-scheme.html#label",
    "title": "Kodierschema",
    "section": "label",
    "text": "label\nDiese Angabe ist meist unnötig, wird also leer gelassen. Erforderlich könnte sie werden, wenn der Ort der Variablen nicht eindeutig ist, weil es viele kleine Interaktionselemente gibt. Dann kann man hier ‘Spalte 2 Zeile 5’ eintragen, um bei der manuellen Kodierung oder der Datenauswertung die Fehlerrate zu senken.",
    "crumbs": [
      "Datenstrukturen",
      "Kodierschema"
    ]
  },
  {
    "objectID": "data-structures/coding-scheme.html#sourcetype",
    "href": "data-structures/coding-scheme.html#sourcetype",
    "title": "Kodierschema",
    "section": "sourceType",
    "text": "sourceType\nHier wird festgelegt, woher der Wert der Variablen kommt:\n\nBasisvariablen\n\nBASE: Es handelt sich um eine Basisvariable. Der Wert stammt also aus der Interaktion der Testperson mit dem Testsystem.\nBASE_NO_VALUE: Es handelt sich um eine Variable im Datensatz der Testdurchführung, die aber nie einen Antwortwert hat oder deren Wert stets ignoriert werden soll.\n\nAbleitung basierend auf dem Wert der Antwort\n\nCOPY_VALUE: Der Wert dieser abgeleiteten Variable ist eine identische Kopie eines Wertes einer anderen Variable. Dies ist erforderlich, wenn ein Eingabewert nicht nur eine isolierte Information liefern soll, sondern mehrere Aspekte des Wertes getrennt analysiert und also kodiert werden sollen. Beispiel: Es soll getrennt bewertet werden, ob die Großschreibung eingehalten und das Dehnungs-H richtig gesetzt wurde (Orthografie-Items).\nUNIQUE_VALUES: Der Wert dieser abgeleiteten Variablen ist ein Boolscher Wert true/false mit dem festgestellt werden kann, ob die Werte der Quellvariablen eindeutig sind. Sowie einer der Werte mehrfach vorkommt, wird false gesetzt. Bei dieser Ableitung reicht es, wenn eine der Quellvariablen den Status VALUE_CHANGED hat.\nSOLVER: Diese Ableitung setzt numerische Werte bei den Quellvariablen voraus und verknüpft diese mit einem mathematischen Ausdruck, der als separater Parameter übergeben werden muss (s. u.). Es entsteht wieder ein numerischer Wert.\n\nAbleitung basierend auf dem Code oder Score der Antwort\n\nCONCAT_CODE: Der Wert dieser abgeleiteten Variable setzt sich aus den Codes anderer Variablen zusammen. Die Integer-Werte der Codes werden mit dem Trennzeichen ’_’ aneinander gekettet. Der neue Wert der Variablen ist also ein String.\nSUM_CODE: Der Wert dieser abgeleiteten Variable ist der Summenwert der Codes anderer Variablen. Durch geschicktes Festlegen der Codes lassen sich gut zusammenfassende Werte bilden. Der neue Wert der Variablen ist also ein Integer.\nSUM_SCORE: Der Wert dieser abgeleiteten Variable ist der Summenwert der Scores anderer Variablen. Damit wird meistens die Bewertung mehrerer Antworten für ein Item zusammengefasst. Ein Item gilt also dann als richtig beantwortet, wenn einige Teilleistungen richtig sind. Der neue Wert der Variablen ist ein Integer.\n\nMANUAL: Diese Ableitung basiert zwar auf anderen Variablen, es werden aber weder Wert, Code noch Score verwendet. Statt dessen erfolgt eine manuelle Kodierung der abgeleiteten Variablen mit Blick auf alle Werte der Variablen, die als Quelle angegeben sind.",
    "crumbs": [
      "Datenstrukturen",
      "Kodierschema"
    ]
  },
  {
    "objectID": "data-structures/coding-scheme.html#sourceparameters",
    "href": "data-structures/coding-scheme.html#sourceparameters",
    "title": "Kodierschema",
    "section": "sourceParameters",
    "text": "sourceParameters\nÜber diese Parameter wird die Ableitung gesteuert bzw. der Wert noch einmal verändert vor der Kodierung.\n\nsolverExpression: Nur für Ableitung SOLVER; hier ist der Ausdruck zu übergeben, mit dem die Werte bei der Ableitung verknüpft werden. Es müssen für alle Variablenwerte Platzhalter existieren in der Form ${var04}. Diese Stelle wird ersetzt durch den Wert der Variablen var04, bevor der Ausdruck an die Bibliothek math.js zur Auswertung übergeben wird. Alle referenzierten Variablen müssen in deriveSources (s. u.) gelistet sein. Der Funktionsumfang des Ausdruckes richtet sich nach math.evaluate(). Wenn der Wert für den Ausdruck leer ist oder wenn die referenzierten Variablen nicht gefunden werden, wird der Status DERIVE_ERROR gesetzt.\nprocessing: Diese Schalter regeln spezielle Umformungen, die die anschließende Kodierung vorbereitet. Es handelt sich technisch um eine Liste von Schlüsselworten, deren Vorhandensein in der Liste den Schalter auf ‘ON’ setzt:\n\nNO_CODING: Nur für Basisvariablen; legt fest, dass der Wert der Variablen nicht kodiert werden soll, sondern anderen Zwecken dient. Beispiele: (1) Eine abgeleitete Variable, die sich auf diese Variable bezieht, wird manuell kodiert. (2) Der Wert wird über einen separaten Prozess kodiert (z. B. Kodierung von Berufen). (3) Der Wert wird nicht kodiert, sondern unterliegt einem Rating (Einschätzung der Antwortgüte über Gleitkommazahl). Das Setzen dieses Parameters verhindert, dass das Kodierschema der Variablen als mangelhaft markiert wird.\nTAKE_DISPLAYED_AS_VALUE_CHANGED: Nur für Basisvariablen; legt fest, dass der Wert der Variablen auch ausgewertet wird, wenn die Variable den Status DISPLAYED hat. Ansonsten werden nur Variablen berücksichtigt, deren Status auf VALUE_CHANGED gesetzt ist.\nTAKE_EMPTY_AS_VALID: Nur für Basisvariablen; legt fest, dass ein leerer Wert als gültig angesehen wird und in die Kodierung gegeben wird. Das Standardverhalten bei leerer Antwort ist das Setzen des Status’ INVALID. “Leer” bedeutet hier ein leerer String oder ein leeres Array.\nREMOVE_ALL_SPACES, REMOVE_DISPENSABLE_SPACES, TO_NUMBER, TO_LOWER_CASE: Nur für Ableitung UNIQUE_VALUES; die Werte werden vor der Gleichheitsprüfung transformiert. So kann man verhindern, dass ein führendes Leerzeichen oder eine vorgesetzte ‘0’ eine Verschiedenheit vortäuscht. Achtung: Wenn TO_NUMBER nicht erfolgreich war, also z. B. ein String nicht in eine Zahl überführt werden konnte, wird ‘0’ gesetzt. Passiert dies zweimal, liefert die Ableitung false.\nSORT: Nur für Ableitung CONCAT_CODE; wenn es egal ist, welche Variable welchen Code liefert, erleichtert eine Sortierung die Kodierung.",
    "crumbs": [
      "Datenstrukturen",
      "Kodierschema"
    ]
  },
  {
    "objectID": "data-structures/coding-scheme.html#derivesources",
    "href": "data-structures/coding-scheme.html#derivesources",
    "title": "Kodierschema",
    "section": "deriveSources",
    "text": "deriveSources\nDies ist eine Liste von IDs der Variablen, die als Quelle dienen. Die Reihenfolge ist verbindlich, was allerdings nur beim Ableitungstyp CONCAT_CODE eine Rolle spielt, sofern nicht als Parameter SORT gesetzt wurde.\nWenn eine Variable angegeben wurde, die nicht im Kodierschema enthalten ist, wird der Status DERIVE_ERROR gesetzt.\n\n\n\n\n\n\nID – nicht Alias!\n\n\n\nAn dieser Stelle ist wichtig zu betonen, dass bei deriveSources stets die ID und nicht der Alias verwendet wird. Der Vorteil ist, dass eine Umbenennung (also eine Änderung des Alias) keine Auswirkung auf die Ableitung hat. Der Nachteil ist, dass beim Blick auf das Kodierschema Irritationen auftreten können, weil man in der UI nur den Alias sieht.",
    "crumbs": [
      "Datenstrukturen",
      "Kodierschema"
    ]
  },
  {
    "objectID": "data-structures/coding-scheme.html#processing",
    "href": "data-structures/coding-scheme.html#processing",
    "title": "Kodierschema",
    "section": "processing",
    "text": "processing\nÜber diese Schalter kann man den generellen Umgang mit Werten und Vergleichswerten verändern. Es handelt sich technisch um eine Liste von Schlüsselworten, deren Vorhandensein in der Liste den Schalter auf ‘ON’ setzt:\n\nIGNORE_CASE: Groß- und Kleinschreibung spielt keine Rolle. Sowohl der Antwort-Wert als auch der Vergleichswert einer Regel werden vor dem Vergleich in Großbuchstaben umgewandelt (s. JavaScript toUpperCase()).\nIGNORE_ALL_SPACES, IGNORE_DISPENSABLE_SPACES: Leerzeichen spielen keine Rolle. Sowohl im Antwortwert als auch im Vergleichswert einer Regel werden vor dem Vergleich alle Leerzeichen (ALL) oder Leerzeichen am Beginn und am Ende sowie doppelte Leerzeichen (DISPENSABLE) entfernt. Als Leerzeichen dient hier die Zeichenklasse \\\\sgemäß JavaScript reguläre Ausdrücke.\nSORT_ARRAY: Sofern der Antwortwert aus einem Array besteht, wird dieses vor der Kodierung sortiert. Leere Antwortwerte im Array werden ans Ende geschoben. Dies kann die Kodierregeln erheblich vereinfachen.\nREPLAY_REQUIRED: Mit dieser Information wird darüber informiert, dass eine Kodierung nicht abstrakt mit dem Antwortwert erfolgen kann, sondern über eine Ansicht der Unit mit den Antwortwerten. Diese Information kann hilfreich bei der Planung der Kodierungen sein.\nATTACHMENT: Der Antwortwert ist ein Verweis auf eine externe Datei. Diese muss dann für die Kodierung herangezogen werden. Beispielsweise könnte ein Foto einer Zeichnung oder eine Audio-Aufnahme auf diese Art als Antwort kodiert werden.\n\nDie Schalter IGNORE_CASE, IGNORE_ALL_SPACES und IGNORE_DISPENSABLE_SPACES gelten nur für die Regel MATCH. Bei MATCH_REGEX wird bei IGNORE_CASE das i-Flag gesetzt, die anderen Schalter werden ignoriert. Bei den numerischen Regeln werden alle Schalter ignoriert.",
    "crumbs": [
      "Datenstrukturen",
      "Kodierschema"
    ]
  },
  {
    "objectID": "data-structures/coding-scheme.html#fragmenting",
    "href": "data-structures/coding-scheme.html#fragmenting",
    "title": "Kodierschema",
    "section": "fragmenting",
    "text": "fragmenting\nÜber einen regulären Ausdruck kann ein Antwortwert zerlegt werden. Interaktionselemente können komplexe Daten in einfache Strings mit definierten Trennzeichen konvertieren, und durch die Fragmentierung werden die Teildaten getrennt auswertbar. Eine Regel (s. u.) bezieht sich dann nicht auf den gesamten Antwortwert, sondern nur auf ein Fragment. Es werden keine geschachtelten Gruppen unterstützt.\n\nBeispiel 1: Ein Textelement in einem Player speichert eine Textmarkierung durch die Testperson über einen Wert 23_92_yellow, was der Startposition, der Endposition und der Farbe der Markierung entspricht. Der Wert kann über den regulären Ausdruck ^(\\d+)_(\\d+)_(\\w+)$ fragmentiert werden, so dass man die einzelnen Informationen getrennt bewerten kann.\n\n\nBeispiel 2: Eine Eingabe 2 kg kann über (\\d+)\\s*(\\w+) zerlegt werden.",
    "crumbs": [
      "Datenstrukturen",
      "Kodierschema"
    ]
  },
  {
    "objectID": "data-structures/coding-scheme.html#manualinstruction",
    "href": "data-structures/coding-scheme.html#manualinstruction",
    "title": "Kodierschema",
    "section": "manualInstruction",
    "text": "manualInstruction\nSollten für alle codespezifischen Instruktionen (s. u.) allgemeine übergreifende Festlegungen gewünscht sein, dann können diese hier hinterlegt werden. Beispielsweise kann man hier die Kodieranweisung eingeben, es möge die Rechtschreibung bei allen Codes beachtet werden.\nDieser Text kann Html-Formatierungen enthalten. Dazu gehören auch Bilder, die dann über die Binärkodierung base64 eingebettet sind.\n\n\n\n\n\n\nSicherheitshinweis\n\n\n\nBei der Anzeige dieser Texte ist stets darauf zu achten, dass Code entfernt wird (über sog. HTML Sanitizer). Ein Verzicht darauf würde eine Sicherheitslücke bedeuten.\n\n\nIm Prozess der Erarbeitung der Kodiervorschriften kann es nützlich sein, diesen Text als allgemeinen Notizzettel zu verwenden. Erste Überlegungen oder Hinweise einer Aufgabenentwicklerin können hier gespeichert werden (z. B. ‘dritte Option ist richtig’), und später könnte ein erfahrener Autor die genauen Code-Regeln definieren.",
    "crumbs": [
      "Datenstrukturen",
      "Kodierschema"
    ]
  },
  {
    "objectID": "data-structures/coding-scheme.html#codemodel",
    "href": "data-structures/coding-scheme.html#codemodel",
    "title": "Kodierschema",
    "section": "codeModel",
    "text": "codeModel\nÜber diesen Parameter wird festgelegt, ob während der Bearbeitung nur die Formularelemente für die Regeln, nur die für die manuelle Kodierung oder alles angezeigt wird. Die möglichen Werte lauten entsprechend RULES_ONLY, MANUAL_ONLY und MANUAL_AND_RULES.",
    "crumbs": [
      "Datenstrukturen",
      "Kodierschema"
    ]
  },
  {
    "objectID": "data-structures/coding-scheme.html#page",
    "href": "data-structures/coding-scheme.html#page",
    "title": "Kodierschema",
    "section": "page",
    "text": "page\nSollte der Player die Unit auf verschiedene Seiten verteilen, dient dies normalerweise dem Verteilen eines umfangreichen Inhaltes auf u. U. nicht sichtbare Bereich. Es ist dann ein Blättern nötig, um alle Interaktionselemente zu erreichen. Bei der Kodierung ist es sehr hilfreich, wenn man beim Replay – also der Anzeige des letzten Standes der Beantwortung – gleich zur richtigen Seite der Variablen springt und nicht erst blättern muss. Ein leerer Eintrag ''bedeutet, dass es entweder nur eine Seite gibt oder dass die Variable nicht verlässlich einer Seite zugeordnet werden kann (z. B. bei abgeleiteten Variablen).",
    "crumbs": [
      "Datenstrukturen",
      "Kodierschema"
    ]
  },
  {
    "objectID": "data-structures/coding-scheme.html#id-1",
    "href": "data-structures/coding-scheme.html#id-1",
    "title": "Kodierschema",
    "section": "id",
    "text": "id\nDies ist der Wert, der als Ergebnis der Kodierung dem Parameter code der Antwortdaten zugewiesen wird. Es handelt sich um einen numerischen ganzahligen Wert.\nDiese id kann auch den Wert null annehmen. Dann bleiben die Parameter code und score gleich 0, aber der Parameter status wird auf den Wert INVALID gesetzt. Es sind dann also Bedingungen beschrieben, die die Antwort als ungültig klassifizieren sollen. Beispiel: Eine alternative Auswahl hat 4 Optionen. Dann kann man für diese vier Optionen reguläre Codes 1-4 vorsehen, und eine abweichende Antwort (‘Alle anderen Antworten’) ist ungültig. Damit ist das Kodierschema ‘geschlossen’, d. h. es gibt immer ein eindeutiges Ergebnis.\n\n\n\n\n\n\nGefahr von Verschleiern eines Problems\n\n\n\nWenn ein eigentlich unmöglicher Wert mit INVALID markiert wird, könnte ein ernstes Problem in der Datenverarbeitung oder im Player dahinter stecken. Derartige Fälle sollten stets genauer untersucht werden.",
    "crumbs": [
      "Datenstrukturen",
      "Kodierschema"
    ]
  },
  {
    "objectID": "data-structures/coding-scheme.html#type",
    "href": "data-structures/coding-scheme.html#type",
    "title": "Kodierschema",
    "section": "type",
    "text": "type\nÜber den Typ RESIDUAL_AUTO kann festgelegt werden, dass eine Kodierung abgeschlossen wird: Alle anderen Codes werden über Regeln geprüft, und wenn keiner zutrifft, wird die Code-Id mit diesem Typ zugewiesen. Die anderen Code-Typen haben keine Auswirkung auf die automatische Kodierung, sondern steuern nach bestimmten Konventionen nachgelagerte Arbeitsschritte oder die Darstellung beim Editieren oder Kodieren:\n\n\n\n\n\n\n\n\n\n\nTyp\nErläuterung\nStandard-Label\nStandard-Id\nStandard-Score\n\n\n\n\nFULL_CREDIT\nEine vollständig richtige Antwort.\nrichtig\n1 bzw. 11, 12, usw.\n1\n\n\nPARTIAL_CREDIT\nEine teilweise richtige Antwort.\nteilweise richtig\n2 bzw. 21, 22, usw.\n0\n\n\nTO_CHECK\nDiese Antwortkategorie ist noch nicht final beschlossen.\nzu prüfen\n3 bzw. 31, 32, usw.\n0\n\n\nNO_CREDIT\nEine falsche Antwort.\nfalsch\n4 bzw. 41, 42, usw.\n0\n\n\nUNSET\nEs soll kein Code-Typ angewendet werden\n(manuell festzugelegen)\nkeine Konvention\n0\n\n\nRESIDUAL\nAlle anderen Antworten\nfalsch\n0\n0",
    "crumbs": [
      "Datenstrukturen",
      "Kodierschema"
    ]
  },
  {
    "objectID": "data-structures/coding-scheme.html#label-1",
    "href": "data-structures/coding-scheme.html#label-1",
    "title": "Kodierschema",
    "section": "label",
    "text": "label\nDieser Parameter kann eine Kurzfassung der Regeln und Instruktionen enthalten und soll darüber für den Code eine Orientierung geben in Listen.",
    "crumbs": [
      "Datenstrukturen",
      "Kodierschema"
    ]
  },
  {
    "objectID": "data-structures/coding-scheme.html#score",
    "href": "data-structures/coding-scheme.html#score",
    "title": "Kodierschema",
    "section": "score",
    "text": "score\nWenn der Code zutrifft, wird auch stets der Parameter score der Antwortdaten gesetzt. Es handelt sich um einen numerischen ganzahligen Wert.",
    "crumbs": [
      "Datenstrukturen",
      "Kodierschema"
    ]
  },
  {
    "objectID": "data-structures/coding-scheme.html#manualinstruction-1",
    "href": "data-structures/coding-scheme.html#manualinstruction-1",
    "title": "Kodierschema",
    "section": "manualInstruction",
    "text": "manualInstruction\nHier sind Instruktionen an eine reale Person gespeichert, die nach Sichtung der Antwort manuell einen Code vergeben soll. Dies kann auch ergänzend zu Regeln sein: Für Standardfälle werden Regeln definiert, die eine automatische Kodierung – soweit möglich – vornehmen, und erst wenn kein Code gefunden wurde, muss eine Person manuell evaluieren. Hierbei ist darauf zu achten, dass keine Regel ‘Alle anderen Antworten’ hinterlegt ist, da sonst dieser Code automatisch vergeben wird und nicht CODING_INCOMPLETE.\nDieser Text kann Html-Formatierungen enthalten. Dazu gehören auch Bilder, die dann über die Binärkodierung base64 eingebettet sind.\n\n\n\n\n\n\nSicherheitshinweis\n\n\n\nBei der Anzeige dieser Texte ist stets darauf zu achten, dass Code entfernt wird (über sog. HTML Sanitizer). Ein Verzicht darauf würde eine Sicherheitslücke bedeuten.",
    "crumbs": [
      "Datenstrukturen",
      "Kodierschema"
    ]
  },
  {
    "objectID": "data-structures/coding-scheme.html#rulesetoperatorand",
    "href": "data-structures/coding-scheme.html#rulesetoperatorand",
    "title": "Kodierschema",
    "section": "ruleSetOperatorAnd",
    "text": "ruleSetOperatorAnd\nWenn dieser boolesche Wert true ist, dann werden die Ergebnisse der Regelsätze mit UND verknüpft. Alle Regelsätze müssen true liefern, damit der Code als zutreffend bewertet wird. Bei false reicht es, dass ein Regelsatz true ergibt (ODER-Verknüpfung).",
    "crumbs": [
      "Datenstrukturen",
      "Kodierschema"
    ]
  },
  {
    "objectID": "data-structures/coding-scheme.html#rulesets",
    "href": "data-structures/coding-scheme.html#rulesets",
    "title": "Kodierschema",
    "section": "ruleSets",
    "text": "ruleSets\nRegelsätze fassen mehrere Regeln zusammen in einer Gruppe. Ein Regelsatz hat folgende Parameter:\n\nvalueArrayPos: Sollte der Antwortwert eine Liste von Werten sein,\n\nstellt dieser Parameter einen Bezug zu einer bestimmten Position im Array her (Datentyp Integer 0..n-1), oder\nsoll mindestens ein Wert im Array gefunden werden, der die Bedingungen erfüllt (Datentyp String ANY oder ANY_OPEN; letzteres legt fest, dass im Array auch andere Werte vorhanden sein dürfen außer denen, für die das Regelset zutrifft), oder\nsollen vor der Auswertung alle Array-Werte bzw. alle Fragmente als numerische Werte interpretiert und summiert werden (Datentyp String SUM), oder\nsoll vor der Auswertung die Anzahl der Array-Werte ermittelt werden (Datentyp String LENGTH)\n\nruleOperatorAnd: Wenn dieser boolesche Wert true ist, dann werden die Ergebnisse der Regeln mit UND verknüpft. Alle Regeln müssen true liefern, damit der Code als zutreffend bewertet wird. Bei false reicht es, dass eine Regel true ergibt (ODER-Verknüpfung).",
    "crumbs": [
      "Datenstrukturen",
      "Kodierschema"
    ]
  },
  {
    "objectID": "data-structures/coding-scheme.html#rules",
    "href": "data-structures/coding-scheme.html#rules",
    "title": "Kodierschema",
    "section": "rules",
    "text": "rules\nRegeln sind Vorschriften, die jeweils einen Wert analysieren nach einem vorgegebenen Muster. Die Anwendung einer Regel liefert stets ein ‘Match’, also ob ein Wert einer bestimmten Erwartung entspricht.\n\nfragment: Das Kodierschema für eine Variable kann im Parameter fragmenting einen regulären Ausdruck enthalten, der einen Wert in mehrere Teile zerlegt (s. o.). Eine Regel kann sich über den Parameter fragment (Datentyp Integer) auf ein bestimmtes Fragment beziehen. Es wird eine ganze positive Zahl als Array-Position erwartet oder ‘-1’ dafür, dass irgendein Fragment die Bedingung erfüllen muss.\nmethod:\n\nMATCH: Es wird eine Übereinstimmung geprüft (String-Vergleich). Hierfür ist EIN Parameter nötig (s. u.). Ist der Parameterwert mehrzeilig, wird pro Zeile die Übereinstimmung geprüft.\nMATCH_REGEX: Es wird eine Übereinstimmung geprüft (String-Vergleich über regulären Ausdruck). Hierfür ist EIN Parameter nötig (s. u.). Ist der Parameterwert mehrzeilig, wird pro Zeile die Übereinstimmung geprüft. Es wird die JavaScript-Funktion match() verwendet, wobei ein Ergebnis ungleich null als positiv gewertet wird.\nNUMERIC_MATCH: Es wird eine Übereinstimmung geprüft. Hierfür ist EIN Parameter nötig (s. u.). Ist der Parameterwert mehrzeilig, wird pro Zeile die Übereinstimmung geprüft. Wert und Vergleichswert werden vor der Prüfung in einen numerischen Wert transformiert. Eventuell vorhandene Leerzeichen werden vorher komplett entfernt, und ein Komma wird ggf. durch einen Dezimalpunkt ersetzt.\nNUMERIC_RANGE: Es wird geprüft, ob der Wert im Bereich “min &lt; Wert &lt;= max” liegt. Hierfür sind ZWEI Parameter nötig (s. u.). Die Aufbereitung der Werte siehe NUMERIC_MATCH.\nNUMERIC_LESS_THAN: Es wird geprüft, ob der Wert kleiner als der Parameterwert ist. Hierfür ist EIN Parameter nötig (s. u.). Die Aufbereitung der Werte siehe NUMERIC_MATCH.\nNUMERIC_MORE_THAN: Es wird geprüft, ob der Wert größer als der Parameterwert ist. Hierfür ist EIN Parameter nötig (s. u.). Die Aufbereitung der Werte siehe NUMERIC_MATCH.\nNUMERIC_MAX: Es wird geprüft, ob der Wert höchstens der Parameterwert ist. Hierfür ist EIN Parameter nötig (s. u.). Die Aufbereitung der Werte siehe NUMERIC_MATCH.\nNUMERIC_MIN: Es wird geprüft, ob der Wert mindestens der Parameterwert ist. Hierfür ist EIN Parameter nötig (s. u.). Die Aufbereitung der Werte siehe NUMERIC_MATCH.\nIS_EMPTY: Prüft, ob der Wert leer ist. Wenn es sich um eine Basisvariable handelt, die kein Array ist, muss bei sourceParameter/processing der Schalter TAKE_EMPTY_AS_VALID gesetzt sein, damit die leere Antwort ausgewertet wird. Diese Regel sollte im ersten Code platziert sein, da andere Regeln u. U. einen CODING_ERROR erzeugen, wenn der Antwortwert leer ist.\nELSE: Diese Regel bezieht sich nicht auf einen bestimmten Wert, sondern trifft immer zu. Sie prüft nichts, sondern der Code, der diese Regel enthält, wird als zutreffend evaluiert. Sie sollte also im letzten Code definiert sein, wenn das Kodierschema geschlossen werden soll.\nIS_NULL: Prüft, ob der Wert null ist im Sinne der Datentypdefinition von JavaScript. Diese Regel sollte im ersten Code platziert sein, da andere Regeln u. U. einen CODING_ERROR erzeugen, wenn der Antwortwert null ist.\nIS_TRUE, IS_FALSE: Prüft, ob der Wert wahr bzw. falsch ist.\n\nparameters: Einige Regeln benötigen einen Parameter, eine sogar zwei. Diese Parameter werden hier gespeichert. Der Datentyp ist eine Liste (Array) von Strings.",
    "crumbs": [
      "Datenstrukturen",
      "Kodierschema"
    ]
  },
  {
    "objectID": "coding/index.html",
    "href": "coding/index.html",
    "title": "Kodieren",
    "section": "",
    "text": "Allgemeines Verfahren\nBevor die Daten in die Analyse gehen, werden sie aufbereitet. Die Kodierung übernimmt hierbei nicht nur die klassische Funktion, die Antwort einer Kategorie zuzuordnen, sondern setzt auch vielfältige Vorschriften zur Anzeige von Fehlerzuständen um. Die Prozesse der Kodierung setzen direkt an der Datenerzeugung an und haben so eine herausragende Funktion bei der Sicherung der Datenqualität.\n\n\n\n\n\nflowchart TD\n    subgraph Input\n        T[\"Antworten\"]\n        style T fill:white\n        style T stroke:black\n    end\n    style Input fill:#ffc\n    style Input stroke:#996\n    style Input color:black\n    subgraph Kodierung\n        F[Filter gültige Antworten]\n        style F fill:white\n        style F stroke:white\n        A1[Autocoder 1. Lauf]\n        style A1 fill:white\n        style A1 stroke:white\n        M[Manuelle Kodierung]\n        style M fill:white\n        style M stroke:white\n        A2[Autocoder 2. Lauf]\n        style A2 fill:white\n        style A2 stroke:white\n    end\n    style Kodierung fill:#996\n    style Kodierung stroke:#996\n    style Kodierung color:black\n    subgraph Output\n        K[Kodierte valide Werte]\n        style K fill:white\n        style K stroke:black\n        W[Invalide Werte]\n        style W fill:white\n        style W stroke:black\n        K --&gt; PDS[Primärer Datensatz]\n        W --&gt; PDS\n        style PDS fill:#cf9\n        style PDS stroke:black\n        PDS --&gt; ADS[Analyse-Datensatz]\n        style ADS fill:#cf9\n        style ADS stroke:black\n    end\n    style Output fill:#ffc\n    style Output stroke:#996\n    style Output color:black\n    T --&gt; F\n    F --&gt; A1\n    A1 --&gt; K\n    A1 --&gt; M\n    M --&gt; A2\n    A2 --&gt; W\n    A2 --&gt; K\n    A1 --&gt; W\n    F --&gt; W\n\n\n Kodierung Ablauf \n\n\n\nAusgehend von den Rohdaten, die im Format iqb-standard vorliegen, müssen folgende Arbeitsschritte vorgenommen werden:\n\nFilter gültiger Antworten: Eine Kodierung ist nur für Antworten erforderlich, die gültig sind.\nAutocoder 1. Lauf: Soweit möglich, werden die Vorschriften im Kodierschema genutzt, um automatisch zu kodieren. Sollten die Vorschriften nicht ausreichen, bleiben Kodierfälle offen. Diese Fälle sind auf besondere Art markiert, um sie der manuellen Kodierung zuzuführen.\nBei der manuelle Kodierung erfolgt die Bewertung der Antwort über besonders qualifizierte Personen.\nAnschließend erfolgt ein zweiter Lauf des Autocoders. Es ist jetzt möglich, mit allen vorliegenden Bewertungen alle nötigen Ableitungen abzuschließen. Für die spätere Beurteilung der Datenqualität ist die Zuweisung von bestimmten Status-Werten für invalide Kodierfälle nötig.\nInvalide Werte werden am IQB in Missings rekodiert. Zusammen mit den Scores aus dem primären Datensatz ergeben sie den Analyse-Datensatz.\n\n\n\nWerte für Status einer Antwort\n\n\n\n\n\nflowchart TD\n    A[Antwort VALUE_CHANGED] --&gt; K[\"Automatische Kodierung + Ableitung\"]\n\n    subgraph Kodierung_1\n        K1[CODING_COMPLETE]\n        style K1 fill:#6f9\n        K6[DERIVE_PENDING]\n        style K6 fill:white\n        K2[CODING_INCOMPLETE]\n        style K2 fill:white\n        K5[CODING_ERROR]\n        style K5 fill:#f60\n        K3[NO_CODING]\n        style K3 fill:#9cf\n        K4[INVALID]\n        style K4 fill:#fc6\n    end\n    style Kodierung_1 fill:#b3b3cc\n    style Kodierung_1 color:#b3b3cc\n    K --&gt; K1\n    K --&gt; K6\n    K --&gt; K2\n    K --&gt; K5\n    K --&gt; K3\n    K --&gt; K4\n\n    K6 --&gt; KK\n\n    R[\"Manuelle Kodierung\"]\n    K2 --&gt; R\n    K5 --&gt; R\n    K3 --&gt; RE[\"Rating / Transcript\"]\n    style RE fill:#9cf\n\n    subgraph Kodierung_2\n        K2_1[CODING_COMPLETE]\n        style K2_1 fill:#6f9\n        K2_4[INVALID]\n        style K2_4 fill:#fc6\n        K2_5[CODING_ERROR]\n        style K2_5 fill:#fc6\n    end\n    style Kodierung_2 fill:#b3b3cc\n    style Kodierung_2 color:#b3b3cc\n    R --&gt; K2_1\n    R --&gt; K2_4\n    R --&gt; K2_5\n\n    KK[\"Automatische Kodierung + Ableitung\"]\n    K2_1 --&gt; KK\n    K2_4 --&gt; KK\n    K2_5 --&gt; KK\n    subgraph Kodierung_3\n        K3_1[CODING_COMPLETE]\n        style K3_1 fill:#6f9\n        K3_4[INVALID]\n        style K3_4 fill:#fc6\n        K3_5[CODING_ERROR]\n        style K3_5 fill:#fc6\n    end\n    style Kodierung_3 fill:#b3b3cc\n    style Kodierung_3 color:#b3b3cc\n    KK --&gt; K3_1\n    KK --&gt; K3_4\n    KK --&gt; K3_5",
    "crumbs": [
      "Kodierung"
    ]
  },
  {
    "objectID": "coding/valid-responses.html",
    "href": "coding/valid-responses.html",
    "title": "Gültige Antworten",
    "section": "",
    "text": "In die Kodierung gehen nur Fälle ein, die den Status VALUE_CHANGED haben:\n\n\n\n\n\nflowchart TD\n    subgraph Test\n        A[UNSET]\n        style A fill:white\n        B[NOT_REACHED]\n        style B fill:white\n        C[DISPLAYED]\n        style C fill:white\n        D[VALUE_CHANGED]\n        style D fill:white\n    end\n    style Test fill:#b3b3cc\n    A --&gt; F[\"Fehler in Programmierung\"]\n    style F fill:#f60\n    B --&gt; G[NOT_REACHED]\n    style G fill:#fc6\n    C --&gt; H{{TAKE_DISPLAYED_AS_VALUE_CHANGED ?}}\n    style H fill:white\n    H --&gt; |NEIN| L[DISPLAYED]\n    style L fill:#fc6\n    D --&gt; HX{{Empty ?}}\n    T[VALUE_CHANGED]\n    H --&gt; |JA| T\n    T --&gt; HX\n    style HX fill:white\n    HX --&gt; |NEIN| K[\"Kodierung\"]\n    X --&gt; |JA| K[\"Kodierung\"]\n    HX --&gt; |JA| X{{TAKE_EMPTY_AS_VALID ?}}\n    X --&gt; |NEIN| XY[INVALID]\n    style X fill:white\n    style XY fill:#fc6\n\n\n\n\n\n\nDer Begriff leer bezeichnet einen leeren String \"\" oder - wenn ein Array von Werten erwartet wird - ein Array mit 0 Elementen \"[]\".\nVALUE_CHANGED meint an dieser Stelle den geprüften Status, d. h. es kann auch DISPLAYED einschließen, wenn TAKE_DISPLAYED_AS_VALUE_CHANGED gesetzt ist, und prüft, dass der Wert nicht leer ist bzw. TAKE_EMPTY_AS_VALID gesetzt ist.",
    "crumbs": [
      "Kodierung",
      "Gültige Antworten"
    ]
  },
  {
    "objectID": "coding/missings.html",
    "href": "coding/missings.html",
    "title": "IQB-Missings",
    "section": "",
    "text": "Mit dem Begriff “Missings” werden Zustände in den Daten kodiert, die von einer normalen auswertbaren Antwort abweichen. Statt eines Wertes, der für die Antwort bzw. für den Code einer Antwort steht, wird in den Datensatz ein Wert eingetragen, der eine fehlerhafte bzw. von der erwarteten Beantwortung abweichende Situation beschreibt. Üblicherweise sind gültige, zulässige Antworten mit positiven Zahlen ausgedrückt, ein Missing jedoch mit einem negativen Wert.",
    "crumbs": [
      "Kodierung",
      "IQB-Missings"
    ]
  },
  {
    "objectID": "coding/missings.html#status-missing",
    "href": "coding/missings.html#status-missing",
    "title": "IQB-Missings",
    "section": "Status → Missing",
    "text": "Status → Missing\n\n\n\n\n\n\n\n\nStatus\nNeuer Code\nBeschreibung\n\n\n\n\nINVALID\n-98\nmir - missing invalid response\n\n\nCODING_ERROR\n-97\nmci - missing coding impossible\n\n\nUNSET, DISPLAYED\n-99\nmbo - missing by omission\n\n\nNOT_REACHED\n-96 oder -99\nmnr - missing not reached oder mbo - missing by omission",
    "crumbs": [
      "Kodierung",
      "IQB-Missings"
    ]
  },
  {
    "objectID": "coding/missings.html#missing-by-design",
    "href": "coding/missings.html#missing-by-design",
    "title": "IQB-Missings",
    "section": "Missing by Design",
    "text": "Missing by Design\nDie Ermittlung von NOT_REACHED bezog sich bisher nur auf die jeweilige Unit. Für die Analyse muss diese Sicht jedoch auf das Testinstrument (Testheft) erweitert werden. Items von Units, die nicht in den Antwortdaten zu finden sind, aber beantwortet werden sollten, müssen neu in die Itemmatrix aufgenommen werden. Hierzu muss die Abfolge der Units (Sequenz) für jedes Testinstrument bekannt sein sowie ggf. Blockgrenzen bekannt sein. Welcher Missing-Code vergeben wird, richtet sich dann nach der Position der Unit bzw. danach, ob bis zum Ende des Tests bzw. des Blocks noch Antworten vorliegen.\nAnschließend werden üblicherweise Items hinzugefügt, die den Personen nicht vorgelegt wurden und die also planmäßig nicht beantwortet wurden. Dies dient der Vervollständigung der Matrix für die Datenverarbeitung. Den Items wird der Code -94 (mbd - missing by design) zugewiesen.",
    "crumbs": [
      "Kodierung",
      "IQB-Missings"
    ]
  },
  {
    "objectID": "coding/derive.html",
    "href": "coding/derive.html",
    "title": "Ableitungen",
    "section": "",
    "text": "Ob eine Ableitung möglich ist, ist vom Status der Quellvariablen und von der Ableitungsmethode sourceType abhängig. Für jede Quellvariable muss einer der folgenden Status zutreffen, damit eine Ableitung erfolgt:\n\nZulässiger Status nach Ableitungsmethode\n\n\n\n\n\n\nAbleitungsmethode\nzulässiger Status\n\n\n\n\nMANUAL\nINVALID, VALUE_CHANGED1, CODING_COMPLETE, CODING_INCOMPLETE, CODING_ERROR, NO_CODING\n\n\nCOPY_VALUE, UNIQUE_VALUES, SOLVER\nVALUE_CHANGED2, CODING_COMPLETE, CODING_INCOMPLETE, CODING_ERROR, NO_CODING\n\n\nCONCAT_CODE, SUM_CODE, SUM_SCORE\nCODING_COMPLETE\n\n\n\nBei der Ableitungsmethode MANUAL wird die abgeleitete Variable ggf. neu angelegt und dann der Status CODING_INCOMPLETE gesetzt. Auch wenn Regeln für die Kodierung der abgeleiteten Variable hinterlegt sein sollten, wird nie eine automatische Kodierung versucht. Ist die Variable bereits vorhanden, wird deren Status durch den Autocoder nicht verändert.\nBei allen anderen Ableitungsmethoden versucht der Autocoder eine Kodierung entsprechend der Parameter und Regeln.",
    "crumbs": [
      "Kodierung",
      "Ableitungen"
    ]
  },
  {
    "objectID": "coding/derive.html#schritt-1-killer",
    "href": "coding/derive.html#schritt-1-killer",
    "title": "Ableitungen",
    "section": "Schritt 1: Killer",
    "text": "Schritt 1: Killer\nWenn eine der Quellvariablen einen der folgenden linken Status hat, dann erhält die abgeleitete Variable den rechten Status - egal, welchen Status die anderen Quellvariablen haben. Die Liste wird von oben nach unten abgearbeitet.\n\nUNSET → UNSET\nDERIVE_ERROR → DERIVE_ERROR\nNO_CODING → DERIVE_ERROR\nCODING_ERROR → CODING_ERROR\nINVALID → INVALID",
    "crumbs": [
      "Kodierung",
      "Ableitungen"
    ]
  },
  {
    "objectID": "coding/derive.html#schritt-2-warten-auf-manuelle-kodierung",
    "href": "coding/derive.html#schritt-2-warten-auf-manuelle-kodierung",
    "title": "Ableitungen",
    "section": "Schritt 2: Warten auf manuelle Kodierung",
    "text": "Schritt 2: Warten auf manuelle Kodierung\nDie Ableitungsmethoden CONCAT_CODE, SUM_CODE und SUM_SCORE setzen eine vollständige Kodierung voraus: CODING_COMPLETE. Sollte eine oder mehrere Quellvariablen den Status CODING_INCOMPLETE oder DERIVE_PENDING haben, dann wird der Status der abgeleiteten Variable auf DERIVE_PENDING gesetzt.",
    "crumbs": [
      "Kodierung",
      "Ableitungen"
    ]
  },
  {
    "objectID": "coding/derive.html#schritt-3-erben-von-fehlerzuständen",
    "href": "coding/derive.html#schritt-3-erben-von-fehlerzuständen",
    "title": "Ableitungen",
    "section": "Schritt 3: Erben von Fehlerzuständen",
    "text": "Schritt 3: Erben von Fehlerzuständen\nFür die verbliebenen Fehlerzustände der Ableitungen soll der Status gezielt gesetzt werden, um die Nachbereitung oder das Setzen von Missings zu erleichtern:\n\nEs gibt mindestens einen zulässigen Status und mindestens einen unzulässigen Status → INVALID\nEs gibt keinen zulässigen Status und alle Status sind gleich → Übernahme des Status der Quellvariablen für die abgeleitete Variable\nDie Quellvariablen haben einen Mix aus NOT_REACHED, DISPLAYED oder PARTLY_DISPLAYED → PARTLY_DISPLAYED",
    "crumbs": [
      "Kodierung",
      "Ableitungen"
    ]
  },
  {
    "objectID": "coding/derive.html#footnotes",
    "href": "coding/derive.html#footnotes",
    "title": "Ableitungen",
    "section": "Fußnoten",
    "text": "Fußnoten\n\n\nVALUE_CHANGED meint an dieser Stelle den geprüften Status, d. h. es kann auch DISPLAYED einschließen, wenn TAKE_DISPLAYED_AS_VALUE_CHANGED gesetzt ist, und prüft, dass der Wert nicht leer ist bzw. TAKE_EMPTY_AS_VALID gesetzt ist.↩︎\nVALUE_CHANGED meint an dieser Stelle den geprüften Status, d. h. es kann auch DISPLAYED einschließen, wenn TAKE_DISPLAYED_AS_VALUE_CHANGED gesetzt ist, und prüft, dass der Wert nicht leer ist bzw. TAKE_EMPTY_AS_VALID gesetzt ist.↩︎",
    "crumbs": [
      "Kodierung",
      "Ableitungen"
    ]
  },
  {
    "objectID": "data-structures/itc-ToolBox-Output/tc-merge.html",
    "href": "data-structures/itc-ToolBox-Output/tc-merge.html",
    "title": "Output itc-ToolBox: TC-Merge",
    "section": "",
    "text": "person\nEine TC-Merge-Datei ist stets eine Liste von Personen.\n\ngroup: ID der Gruppe laut Testtaker-Xml\nlogin: Name des Logins laut Testtaker-Xml\ncode: Code innerhalb des Booklet-Tags in der Testtaker-Xml (ggf. leer)\nbooklets: Liste der Booklets - s. u.\n\n[\n    {\n        \"group\": \"cxz7hpwr\",\n        \"login\": \"cxz7hpwr\",\n        \"code\": \"1dpe\",\n        \"booklets\": [ ]\n    },\n    {\n        \"group\": \"cxz7hpwr\",\n        \"login\": \"cxz7hpwr\",\n        \"code\": \"1fud\",\n        \"booklets\": [ ]\n    }\n]\nDie itc-ToolBox ist darauf ausgerichtet, bei hohen Datenmengen pro Testtaker-Gruppe eine Datei anzulegen. Möchte man die gesamte Datenmenge einlesen, müssen diese einzelnen Listen zusammengeführt werden. Da die JSON-Datei formatiert ist, kann man entsprechend die erste bzw. letzte Zeile einer Datei löschen bzw. ersetzen.\n\n\nbooklet\n\nid: ID des Booklets laut Booklet-Xml\nlogs: Liste von Log-Einträgen (Ereignissen), bezogen auf das Booklet\n\nts: Zeitstempel des Ereignisses (numerisch)\nkey: Schlüsselwort, das das Ereignis kennzeichnet (Typ), z. B. CURRENT_UNIT_ID, LOADCOMPLETE oder FOCUS\nparameter: Weitere Informationen als String zum Ereignis, abhängig vom Typ\n\nunits: Liste der Units - s. u.\nsessions: Liste von gestarteten Bearbeitungen des Booklets\n\nbrowser: Name und Version des verwendeten Browsers, z. B. Chrome 123.0.0.0\nos: Name und Version des Betriebssystem, z. B. Windows 10\nscreen: Maße des Bildschirmes in Pixel, z. B. 1280 x 720,\nts: Zeitstempel der Ermittlung der Parameter (numerisch), z. B. 1715593740477\nloadCompleteMS: Dauer des Ladeprozesses der Testinhalte (Player, Units, Booklet) in ms (numerisch), z. B. 798\n\n\nEine neue Session wird angenommen, wenn in den Logs das Ereignis LOADCOMPLETE gefunden wurde. Dies zeigt einen abgeschlossenen Ladeprozess der Testinhalte an. Der Startzeitpunkt einer Session kann angenommen werden, wenn man vom Zeitstempel ts den Wert in loadCompleteMS subtrahiert.\n{\n    \"id\": \"ABIEVALBOOKLET_BE_FRANZOESISCH_GN_LONG\",\n    \"logs\": [\n        {\n            \"ts\": 1719466289261,\n            \"key\": \"CONNECTION\",\n            \"parameter\": \"POLLING\"\n        },\n        {\n            \"ts\": 1719466289253,\n            \"key\": \"CONTROLLER\",\n            \"parameter\": \"RUNNING\"\n        },\n        {\n            \"ts\": 1719466289361,\n            \"key\": \"CURRENT_UNIT_ID\",\n            \"parameter\": \"Unit1\"\n        },\n        {\n            \"ts\": 1719466289672,\n            \"key\": \"CONNECTION\",\n            \"parameter\": \"WEBSOCKET\"\n        }\n    ],\n    \"units\": [ ],\n    \"sessions\": [\n        {\n            \"browser\": \"Chrome 103.0.0.0\",\n            \"os\": \"Mac OS 10.12.6\",\n            \"screen\": \"1440 x 900\",\n            \"ts\": 1719466289928,\n            \"loadCompleteMS\": 1805\n        },\n        {\n            \"browser\": \"Chrome 103.0.0.0\",\n            \"os\": \"Mac OS 10.12.6\",\n            \"screen\": \"1440 x 900\",\n            \"ts\": 1719485971651,\n            \"loadCompleteMS\": 1858\n        }\n    ]\n}         \n\n\nunit\n\nid: ID der Unit laut Booklet-Xml; wird benötigt, wenn man die Definition, das Kodierschema oder andere Daten der Unit benötigt\nalias: Alias der Unit\n\ndieser kann in der Booklet-Xml vergeben werden oder er wird automatisch erzeugt, sollte eine Unit mehrfach in einem Booklet vorkommen\nwird kein Alias vergeben, wird hier automatisch die ID der Unit gesetzt\nalle Bezüge in den Logs und Antwortdaten beziehen sich auf den Alias\n\nlaststate: Liste von key/value-Paaren, um bestimmte für das Zurückblättern wichtige Unit-Zustände zu rekonstruieren\nsubforms: Liste der Antworten - s. u.\nchunks: Liste der Pakete der Antworten; die Verona-Spezifikation erlaubt es, dass Antworten nicht einzeln, sondern gebündelt in dataparts geschickt werden\n\nid: jeder Chunk/datapart muss eine ID haben\ntype: Datentyp der Antworten; bei IQB-Daten stets iqb-standard@1.0 bzw. andere Version\nts: Zeitstempel der Speicherung (numerisch)\nvariables: Liste von IDs von Variablen, die mit dem Paket geschickt wurden; sollten Unterformulare genutzt worden sein, wird als Präfix der Wert von subform gesetzt, gefolgt von einem Trenner, z. B. examineecount_0##choice1\n\nlogs: Liste von Log-Einträgen (Ereignissen), bezogen auf die Unit\n\nts: Zeitstempel des Ereignisses (numerisch)\nkey: Schlüsselwort, das das Ereignis kennzeichnet (Typ), z. B. RESPONSE_PROGRESS oder CURRENT_PAGE_ID\nparameter: Weitere Informationen als String zum Ereignis, abhängig vom Typ\n\n\n{\n    \"id\": \"MP_motivation1\",\n    \"alias\": \"MP_motivation1_start\",\n    \"laststate\": [\n        {\n            \"key\": \"PLAYER\",\n            \"value\": \"RUNNING\"\n        },\n        {\n            \"key\": \"PRESENTATION_PROGRESS\",\n            \"value\": \"complete\"\n        },\n        {\n            \"key\": \"RESPONSE_PROGRESS\",\n            \"value\": \"complete\"\n        }\n    ],\n    \"subforms\": [ ],\n    \"chunks\": [\n        {\n            \"id\": \"elementCodes\",\n            \"type\": \"iqb-standard@1.0\",\n            \"ts\": \"1715593741455\",\n            \"variables\": [\n            \"text_4\",\n            \"image_1\",\n            \"button_2\"\n            ]\n        }\n    ],\n    \"logs\": [\n        {\n            \"ts\": 1715593739823,\n            \"key\": \"PLAYER\",\n            \"parameter\": \"LOADING\"\n        },\n        {\n            \"ts\": 1715593740340,\n            \"key\": \"PLAYER\",\n            \"parameter\": \"RUNNING\"\n        },\n        {\n            \"ts\": 1715593741013,\n            \"key\": \"PRESENTATION_PROGRESS\",\n            \"parameter\": \"complete\"\n        },\n        {\n            \"ts\": 1715593741013,\n            \"key\": \"RESPONSE_PROGRESS\",\n            \"parameter\": \"complete\"\n        }\n    ]\n}\n\n\nsubform, response\nEine Antwort nach IQB-Standardformat enthält ein optionales Attribut subform. Für die Datenverarbeitung ist es günstiger, diese Information - die z. B. in Befragungen genutzt wird - zu extrahieren und alle Variablen eines Unterformulars zu bündeln. Aus diesem Grund ist das Datenobjekt für die Antworten nocheinmal strukturiert:\n\nid: ID des Unterformulars bzw. leer\nresponses: Liste der Antwortdaten\n\nid: Variablen-ID\nstatus: Status der Beantwortung; z. B. DISPLAYED oder VALUE_CHANGED\nvalue: Antwortwert als String\n\n\n{\n        \"id\": \"examineecount_0\",\n        \"responses\": [\n            {\n                \"id\": \"sex\",\n                \"status\": \"VALUE_CHANGED\",\n                \"value\": \"2\"\n            },\n            {\n                \"id\": \"choice1\",\n                \"status\": \"VALUE_CHANGED\",\n                \"value\": \"1\"\n            },\n            {\n                \"id\": \"task11grade\",\n                \"status\": \"VALUE_CHANGED\",\n                \"value\": \"14\"\n            },\n            {\n                \"id\": \"choice2\",\n                \"status\": \"VALUE_CHANGED\",\n                \"value\": \"2\"\n            },\n            {\n                \"id\": \"task22grade\",\n                \"status\": \"VALUE_CHANGED\",\n                \"value\": \"14\"\n            }\n        ]\n},\n{\n    \"id\": \"examineecount_1\",\n    \"responses\": [\n        {\n            \"id\": \"sex\",\n            \"status\": \"VALUE_CHANGED\",\n            \"value\": \"2\"\n        },\n        {\n            \"id\": \"choice1\",\n            \"status\": \"VALUE_CHANGED\",\n            \"value\": \"1\"\n        },\n        {\n            \"id\": \"task11grade\",\n            \"status\": \"VALUE_CHANGED\",\n            \"value\": \"9\"\n        },\n        {\n            \"id\": \"choice2\",\n            \"status\": \"VALUE_CHANGED\",\n            \"value\": \"2\"\n        },\n        {\n            \"id\": \"task22grade\",\n            \"status\": \"VALUE_CHANGED\",\n            \"value\": \"9\"\n        }\n    ]\n}\n\n\n\n\n\n\nDatenformat des Antwortwertes\n\n\n\nIn streng typisierten Computersprachen ist die offene IQB-Datenspezifikation des Antwortwertes problematisch. Daher werden hier die Werte in String transformiert. Der Datenwert null ist hierbei in einen reservierten Wert \"#null#\" übersetzt. Auch Array-Werte müssen entsprechend vor der Kodierung transformiert werden.\n\n\n\n\n\n\n\n\nBehandlung großer Antwortwerte\n\n\n\nWenn ein Wert mit den Zeichen data:application/octet-stream;base64 beginnt, handelt es sich meist um die Speicherung einer binären, nicht automatisch kodierbaren Antwort. Um die Datenmenge zu reduzieren, ermöglicht die itc-ToolBox, den Wert als separate Datei zu speichern:\n\nDer Dateiname wird folgendermaßen gebildet:\n\nDaten der Person Gruppe, Login-Name und Code - hintereinander ohne Trennzeichen\nTrennzeichen _\nnumerischer Hash-Wert der Datei (ganzzahlig positiv oder negativ)\nDateiendung .base64\nBeispiel: b7tr7svhb7tr7svh7rbr_-611842233.base64\n\nDer Antwortwert wird ersetzt durch die Zeichenfolge data:application/octet-stream;base64 Filename: '&lt;Dateiname&gt;'",
    "crumbs": [
      "Datenstrukturen",
      "itc-ToolBox Output",
      "Format TC-Merge"
    ]
  },
  {
    "objectID": "data-structures/response.html",
    "href": "data-structures/response.html",
    "title": "Datenstruktur “Antwort”",
    "section": "",
    "text": "Die Spezifikation in englischer Sprache finden Sie hier.",
    "crumbs": [
      "Datenstrukturen",
      "Antwort/Variable"
    ]
  },
  {
    "objectID": "data-structures/response.html#status-bei-ableitung",
    "href": "data-structures/response.html#status-bei-ableitung",
    "title": "Datenstruktur “Antwort”",
    "section": "Status bei Ableitung",
    "text": "Status bei Ableitung\nDas Kodierschema des IQB erlaubt das Definieren neuer Variablen auf der Grundlage eines Wertes oder eines Codes anderer Variablen der Unit. Diese sog. Ableitung kann nur erfolgen, wenn die Quellvariablen einen hinreichenden Status haben:\n\nVariablen, deren Wert (Value) in die abgeleitete Variable eingeht, müssen vor der Kodierung den Status VALUE_CHANGED haben. Es ist auch der Status DISPLAYED möglich, wenn dies bei der Quellvariablen markiert wurde.\nVariablen, deren Code oder Score in die abgeleitete Variable eingeht, müssen den Status CODING_COMPLETE haben.\n\nWenn eine oder mehrere Variablen, deren Werte oder Codes für die Ableitung verwendet werden sollen, einen abweichenden Status haben, erfolgt keine Ableitung. Ist der Status bei allen Variablen gleich, dann wird dieser übernommen. Ansonsten gelten folgende Regeln:\n\n\n\n\n\n\nReihenfolge wichtig\n\n\n\nDie folgende Liste wird genau in dieser Reihenfolge abgearbeitet. Sobald ein Fall zutrifft, wird nicht mit der nächsten Bedingung fortgesetzt.\n\n\n\n\n\n\n\n\n\nBedingung\nStatus der abgeleiteten Variable\n\n\n\n\nMindestens eine der Variablen hat den Status CODING_ERROR\nCODING_ERROR\n\n\nMindestens eine der Variablen hat den Status CODING_COMPLETE und mindestens eine andere einen unzulässigen Status\nINVALID\n\n\nMindestens eine der Variablen hat den Status PARTLY_DISPLAYED oder DISPLAYED und mindestens eine andere NOT_REACHED oder UNSET\nPARTLY_DISPLAYED",
    "crumbs": [
      "Datenstrukturen",
      "Antwort/Variable"
    ]
  }
]